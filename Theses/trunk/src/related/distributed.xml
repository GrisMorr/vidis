<?xml version="1.0" encoding="UTF-8"?>
<section
	xmlns="http://docbook.org/ns/docbook">
	<title>Verwendete verteilte Algorithmen</title>
	<para></para>
	
	<section>
		<title>Vector Clock Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						In verteilten Systemen treten üblicherweise parallel
						verschiedene Ereignisse auf, welche jedoch nicht global,
						also jedem Node, bekannt sind. Sollten diese Ereignisse 
						koordiniert werden müssen kann es zu inkonsistentem oder
						fehlerhaften Verhalten kommen weil es in einem Netzwerk
						keine globale Zeit gibt. Egal wie genau die Knoten zeitlich
						synchronisiert werden, es gibt immer - wenn auch manchmal nur sehr kleine -
						Verzögerungen. Angenommen beide Prozesse markieren
						die Ereignisse mit Zeitstempeln. So reicht es nicht aus,
						diese Zeitstempel zu vergleichen, da die Uhren der Knoten
						schlecht synchronisiert sein könnten und somit ein Vergleich
						der Zeitstempel nicht aussagekräftig ist.
					</para>
					<para>
						Der Vector Clock Algorithmus kann dazu verwendet werden um
						eine partiale Ordnung auf nebenläufigen, gleichläufigen und
						nicht global bekannte Events zu erstellen. Damit ist es 
						möglich zu entscheiden welcher der neuere, gültige Zustand
						in einem verteilten System ist.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Beispiel</term>
				<listitem>
					<para>
						Die Mengen der Nodes (Peers):
						<programlisting>P = { P<subscript>i</subscript> | P<subscript>i</subscript> ist ein Peer, 0 &lt; i &lt; 4 }</programlisting>
						Die Menge der Verbindungen:
						<programlisting>C = { ( P<subscript>1</subscript>, P<subscript>2</subscript> ), ( P<subscript>2</subscript>, P<subscript>3</subscript> )	}</programlisting>
						Die Menge der logischen Uhren gespeichert in P<subscript>i</subscript>:
						<programlisting>V<subscript>P<subscript>i</subscript></subscript> = { x | x = P<subscript>j</subscript>, die logische Uhr von P<subscript>j</subscript> gespeichert in P<subscript>i</subscript> }</programlisting>
						Und folgende Funktion:
						<programlisting>time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) = der Wert der logischen Uhr von P<subscript>j</subscript> in Peer P<subscript>i</subscript></programlisting>
						Grafisch:
						<figure>
							<title>Vector Clock Algorithmus</title>
							<mediaobject>
								<imageobject>
									<imagedata fileref="vectorClockAlgorithm.png" format="PNG" />
								</imageobject>
							</mediaobject>
						</figure>
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						Der Algorithmus basiert auf <quote>Lamport's logical clock</quote>
						Dieser Algorithmus produziert eine totale Ordnung, erfasst
						aber keine Kausalitäten <xref linkend="book_related.distributed.lamport" />
						zwischen den Ereignissen.
					</para>
					<para>
						Um dieses Problem einzugrenzen, geht der Vector Clock Algorithmus einen anderen
						Weg. Jeder Peer speichert seine eigene und die logischen Uhren von erreichbaren
						Knoten. Bei einem Ereignis wird die interne logische Uhr
						erhöht und an die benachbarten Knoten zusammen mit allen bekannten logischen
						Uhren anderer Peers geschickt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Umsetzung in Pseudocode</term>
				<listitem>
					<para>
						Bevor ein Ereignis von P<subscript>i</subscript> ausgeführt wird:
						<programlisting>time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>i</subscript>) = V<subscript>(P<subscript>i</subscript>, P<subscript>i</subscript>)</subscript>+1</programlisting>
Wenn P<subscript>i</subscript> eine Nachricht an P<subscript>j</subscript> sendet:
						<programlisting>M<subscript>(P<subscript>i</subscript>, P<subscript>j</subscript>)</subscript> = ( M, V<subscript>P<subscript>i</subscript></subscript> )							send M<subscript>(P<subscript>i</subscript>, P<subscript>j</subscript>)</subscript></programlisting>
Wenn P<subscript>i</subscript> eine Nachricht M empfängt:
						<programlisting>for j in 1..n do
	time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) = max { time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>), time(M.V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) }
done
</programlisting>
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Fazit</term>
				<listitem>
					<para>
						Mit diesem Algorithmus ist es nun möglich,
						die Kausalitäten zwischen Ereignissen zu erkennen
						und diese so zeitlich zu ordnen. Jeder Prozess
						kann damit beim Erhalt eines jeden Ereignisses
						entscheiden ob das soeben erhaltene Ereignis vor,
						nach oder gleichzeitig zu dem zuletzt erhaltenen Ereignis war.
						Dies ermöglicht eine Kollisionserkennung und je nach
						Anwendungsbereich kann fehlerhaftes Verhalten vermieden werden.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Bully Election Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						Oft ist es in verteilten Systemen notwendig eine 
						Entscheidung mit globaler Auswirkung zentralisiert
						zu treffen. In diesen Fällen muss ein Koordinator
						gewählt werden, der diese Entscheidung übernimmt.
					</para>
					<para>
						Der Bully Election Algorithmus kann dazu verwendet werden
						um in einem Netzwerk mit gleichberechtigten Nodes einen
						Koordinator zu finden.
					</para>
					<para>
						Dieser Algorithmus wurde von Garcia-Molina (1982) entwickelt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösung und Pseudocode</term>
				<listitem>
					<para>
						Der Algorithmus besteht aus 3 Phasen. Zunächst muss
						erkannt werden, ob ein Koordinator vorhanden ist beziehungsweise
						der Koordinator noch reagiert.
						<programlisting>P := der aktuelle Knoten
connected_nodes := { x | x ist verbunden mit P }
for i in connected_nodes do
	if i.ID > P.ID do
		send ELECTION
	done
done
</programlisting>
						Sollte kein Knoten antworten:
						<programlisting>P.coordinator = true</programlisting>
						Sollte ein Knoten mit höherer ID antworten, übernimmt dieser die weitere Wahl
						und P hat seine Aufgabe erfüllt.
						
						<xref linkend="book_related.distributed.bullyelection" />
					</para>
					<note>
						<para>
							Für ein verteiltes System kann es aufwendig sein
							herauszufinden ob eine Knoten-ID größer ist bevor
							eine Nachricht jemals ausgetauscht wurde. Deshalb
							bietet sich für diesen Algorithmus folgende Anpassung.
						</para>
						<para>
							Eine Nachricht wird an alle Nachbarknoten geschickt.
							Die Nachricht enthält die Absenderknoten ID.
							Der Nachbarknoten kann damit entscheiden wie er 
							auf das Paket reagiert indem er seine eigene ID mit
							der ID des Pakets überprüft.
						</para>
					</note>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Byzantinische Generäle</title>
		
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						Die dahinterliegende Idee ist auch bekannt als byzantinisches
						Zustimmungsproblem. Es ist nicht notwendigerweise impliziert,
						dass in einem Netzwerk ausschließlich vertrauenswürdige Peers
						vorkommen. Manchmal gibt es fehlerhafte oder bösartige Knoten.
						Diesen kann nicht vertraut werden. Es muss deshalb eine
						Möglichkeit gefunden werden weiterhin einen <quote>richtigen</quote>
						Zustand des Systems zu wahren.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						Als Lösung bietet sich ein Mehrheitsentscheid an. Es werden dafür
						die Aussagen mehrerer bzw aller Nachbarknoten abgewartet, bevor
						sich ein Peer für eine Option entscheidet. Trivialerweise funktioniert
						dies nur, so lange mehr Nachbarknoten die Wahrheit sagen. Ansonsten
						wird ein korrekter Knoten komprommitiert. Lamport
						bewies 1982, dass in einem System in dem alle Knoten miteinander in
						Verbindung stehen und mit <literal>k</literal> fehlerhaften
						Einheiten mindestens <literal>2k + 1</literal> korrekt funktionierende
						Einheiten vorhanden sein müssen. Die Komplexität dieses Problems
						erhöht sich jedoch für den Fall, dass nicht alle Knoten mit jedem anderen
						Knoten verbunden sind.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>		
	</section>
	
	<section>
		<title>Echo Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Idee</term>
				<listitem>
					<para>
						Der Echo Algorithmus bildet die Grundlage für
						eine Vielzahl an mögliche Anwendungen. Dazu wird
						eine Nachricht an alle Nachbarknoten geschickt, 
						welche bei Erhalt sich den Absender merken und
						die Nachricht weiterschicken. Wenn der Nachbarknoten
						schlussendlich eine Antwort von allen seinen Nachbarknoten
						erhalten hat, schickt dieser seinem <quote>Vaterknoten</quote>
						eine Antwort. <xref linkend="paper_echoalgorithm" />
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Pseudocode</term>
				<listitem>
					<variablelist>
						<varlistentry>
							<term>Schritt 1</term>
							<listitem>
								<para>
									Alle Knoten <literal>P</literal> werden mit folgendem
									Pseudo-Code initialisiert.
								</para>
								<programlisting><![CDATA[P.initiator=FALSE
P.state=WHITE]]></programlisting>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term>Schritt 2</term>
							<listitem>
								<para>
									Ein Knoten <literal>P</literal> startet den Algorithmus indem
									er folgenden Pseudo-Code ausführt.
								</para>
								<programlisting><![CDATA[P.initiator=TRUE
for each i from Neighbours do
	send i EXLORE
done 
]]></programlisting>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term>Schritt 3</term>
							<listitem>
								<para>
									Folgender Pseudo-Code wird ausgeführt, wenn
									ein Knoten <literal>P</literal> die Nachricht <literal>M</literal> vom Nachbar <literal>N</literal> empfängt.
								</para>
								<programlisting><![CDATA[function send N M :=
	send message M to neighbour M

if P.state=WHITE ist AND M=EXPLORE then   
	P.state=RED
	for each i from Neighbours do
		if i!=N do
			send i EXLORE
		done
	done 
	P.parent = N
	P.received += 1
fi
if P.received=#(Neighbours) OR M=ECHO then
	P.state=GREEN
	if P.initiator=TRUE then
		// done
	else
		send P.parent ECHO
	fi
fi]]></programlisting>
							</listitem>
						</varlistentry>
					</variablelist>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Anwendungsbeispiele</term>
				<listitem>
						<para>
							Dieser Algorithmus kann sehr vielseitig eingesetzt werden.
							Zum einen kann damit ein Spannbaum eines verteilten Systems
							aufgebaut werden (siehe vorimplementiertes Demo Modul <quote>mstAlgorithm</quote>).
							Andererseits können damit auch Daten oder Anfragen in ein 
							verteiltes System realisiert werden. Der Algorithmus terminiert
							immer und ist Total da die Befragung aller Knoten aus einem verteilten System
							für die Terminierung benötigt wird. 
						</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Einfache und effiziente Verbesserung</term>
				<listitem>
					<para>
						Wenn jedes Flooding eine eindeutige ID bekommt,
						kann ein Knoten entscheiden ob er eine Flooding-Nachricht
						vom selben Durchlauf bereits erhalten hat. Dadurch
						wird vermieden, dass ein Knoten eine Flooding-Nachricht
						mehrfach bearbeitet. Dieser Algorithmus terminiert ohne
						diese Adaptierung nicht für Netzwerktopologien mit 
						Verbindungsschleifen.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Flooding Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						Der Flooding Algorithmus kann dazu verwendet werden
						um Nachrichten oder Daten in einem Verteilten System
						zu verbreiten. Im wesentlichen sendet ein Knoten an
						alle Nachbarknoten die zu verbreitende Nachricht und
						diese senden sie wiederum an alle Nachbarknoten weiter.
						Der große Nachteil dieses Algorithmus ist, dass eine Nachricht
						mehrfach dupliziert wird und so, falls sie nur für einen
						Empfänger bestimmt war, erheblich viele unnötige Nachrichten
						produziert. Andererseits ist der Algorithmus sehr restistent
						gegen Ausfälle einzelner Knoten. Sollte eine Verbindung
						ausfallen, erreicht eine Nachricht trotz allem den Empfänger
						über eine andere, eventuell längere, Verbindung.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Pseudocode</term>
				<listitem>
					<para>
						Obgleich es sehr viele Abwandlungen und Anpassungen dieses
						Algorithmus gibt funktionieren diese im wesentlichen folgendermaßen.
					</para>
					<variablelist>
						<varlistentry>
							<term>Schritt 1</term>
							<listitem>
								<para>
									Ein Knoten <literal>P</literal> startet den Algorithmus indem
									er Nachricht <literal>M</literal> an
									alle Nachbarknoten schickt.
								</para>
								<programlisting>M.sender=P
for each i from Neighbours do
	send i M
done
</programlisting>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term>Schritt 2</term> 
							<listitem>
								<para>
									Jeder Knoten <literal>P</literal> der die Nachricht M erhält,
									verarbeitet diese und schickt sie an alle
									Nachbarknoten weiter. Die einzige Ausnahme
									ist dabei der Ursprungsknoten.
								</para>
								<programlisting>for each i from Neighbours do
	if i!=M.sender do
		M.sender=P
		send i M
	done
done
</programlisting>
							</listitem>
						</varlistentry>
					</variablelist>
				</listitem>
			</varlistentry>
		</variablelist>		
	</section>
	
</section>
