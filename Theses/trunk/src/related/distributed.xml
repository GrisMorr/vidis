<?xml version="1.0" encoding="UTF-8"?>
<section
	xmlns="http://docbook.org/ns/docbook">
	<title>Verwendete verteilte Algorithmen</title>
	<para></para>
	
	<section>
		<title>Vector Clock Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						In verteilten Systemen treten üblicherweise parallel
						verschiedene Ereignisse auf, welche jedoch nicht global,
						also jedem Node, bekannt sind. Sollten diese Ereignisse 
						koordiniert werden müssen kann es zu inkonsistentem oder
						fehlerhaften Verhalten kommen weil es in einem Netzwerk
						keine globale Zeit gibt. Egal wie genau die Knoten zeitlich
						synchronisiert werden, es gibt immer - wenn auch manchmal nur sehr kleine -
						Verzögerungen. Es reicht somit nicht aus Ereignisse mittels
						Timestamps zu synchronisieren, da ein Ereignis das auf einer
						Node global gesehen zwar vor dem Ereignis auf einer anderen Node aufgetreten ist.
						Die Uhren der verschiedenen Nodes jedoch derart verfälschte
						Timestamps produzieren könnten, dass ein Vergleich dieser Timestamps
						zum gegenteiligen Ergebnis führt.
					</para>
					<para>
						Der Vector Clock Algorithmus kann dazu verwendet werden um
						eine partiale Ordnung auf nebenläufigen, gleichläufigen und
						nicht global bekannte Events zu erstellen. Damit ist es 
						möglich zu entscheiden welcher der neuere, gültige Zustand
						in einem verteilten System ist.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Beispiel</term>
				<listitem>
					<para>
						Die Mengen der Nodes (Peers):
						<programlisting>
							P = { P<subscript>i</subscript> | P<subscript>i</subscript> ist ein Peer, 0 &lt; i &lt; 4 }
						</programlisting>
						Die Menge der Verbindungen:
						<programlisting>
							C = { ( P<subscript>1</subscript>, P<subscript>2</subscript> ), ( P<subscript>2</subscript>, P<subscript>3</subscript> )	}
						</programlisting>
						Die Menge der logischen Uhren gespeichert in P<subscript>i</subscript>:
						<programlisting>
							V<subscript>P<subscript>i</subscript></subscript> = { x | x = P<subscript>j</subscript>, die logische Uhr von P<subscript>j</subscript> gespeichert in P<subscript>i</subscript> }
						</programlisting>
						Und folgende Funktion:
						<programlisting>
							time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) = der Wert der logischen Uhr von P<subscript>j</subscript> in Peer P<subscript>i</subscript>
						</programlisting>
						Grafisch:
						<figure>
							<mediaobject>
								<textobject>
									<para>TODO</para>
								</textobject>
							</mediaobject>
						</figure>
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						Der Algorithmus basiert auf <quote>Lamport's logical clock</quote>
						Dieser Algorithmus produziert eine totale Ordnung, erfasst
						aber keine Kausalitäten (<xref linkend="book_related.distributed.lamport" />)
						zwischen den Ereignissen.
					</para>
					<para>
						Um dieses Problem einzugrenzen, geht der Vector Clock Algorithmus einen anderen
						Weg. Jeder Peer speichert seine eigene und die logischen Uhren von erreichbaren
						Knoten. Bei einem Ereignis wird die interne logische Uhr
						erhöht und an die benachbarten Knoten zusammen mit allen bekannten logischen
						Uhren anderer Peers geschickt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Pseudocode</term>
				<listitem>
					<para>
						Bevor ein Ereignis von P<subscript>i</subscript> ausgeführt wird:
						<programlisting>
							time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>i</subscript>) = V<subscript>(P<subscript>i</subscript>, P<subscript>i</subscript>)</subscript>+1
						</programlisting>
						Wenn P<subscript>i</subscript> eine Nachricht an P<subscript>j</subscript> sendet:
						<programlisting>
							M<subscript>(P<subscript>i</subscript>, P<subscript>j</subscript>)</subscript> = ( M, V<subscript>P<subscript>i</subscript></subscript> )
							send M<subscript>(P<subscript>i</subscript>, P<subscript>j</subscript>)</subscript>
						</programlisting>
						Wenn P<subscript>i</subscript> eine Nachricht M empfängt:
						<programlisting>
							for j in 1..n do
								time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) = max { time(V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>), time(M.V<subscript>P<subscript>i</subscript></subscript>, P<subscript>j</subscript>) }
							done
						</programlisting>
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Bully Election Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						Oft ist es in verteilten Systemen notwendig eine 
						Entscheidung mit globaler Auswirkung zentralisiert
						zu treffen. In diesen Fällen muss ein Koordinator
						gewählt werden, der diese Entscheidung übernimmt.
					</para>
					<para>
						Der Bully Election Algorithmus kann dazu verwendet werden
						um in einem Netzwerk mit gleichberechtigten Nodes einen
						Koordinator zu finden.
					</para>
					<para>
						Dieser Algorithmus wurde von Garcia-Molina (1982) entwickelt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösung und Pseudocode</term>
				<listitem>
					<para>
						Der Algorithmus besteht aus 3 Phasen. Zunächst muss
						erkannt werden, ob ein Koordinator vorhanden ist beziehungsweise
						der Koordinator noch reagiert.
						<programlisting>
							P := der aktuelle Knoten
							connected_nodes := { x | x ist verbunden mit P }
							for i in connected_nodes do
								if i.ID > P.ID do
									send ELECTION
								done
							done
						</programlisting>
						Sollte kein Knoten antworten:
						<programlisting>
							P.coordinator = true
						</programlisting>
						Sollte ein Knoten mit höherer ID antworten, übernimmt dieser die weitere Wahl
						und P hat seine Aufgabe erfüllt.
						
						<xref linkend="book_related.distributed.bullyelection" />
					</para>
					<note>
						<para>
							Für ein verteiltes System kann es aufwendig sein
							herauszufinden ob eine Knoten-ID größer ist bevor
							eine Nachricht jemals ausgetauscht wurde. Deshalb
							bietet sich für diesen Algorithmus folgende Anpassung.
						</para>
						<para>
							Eine Nachricht wird an alle Nachbarknoten geschickt.
							Die Nachricht enthält die Absenderknoten ID.
							Der Nachbarknoten kann damit entscheiden wie er 
							auf das Paket reagiert indem er seine eigene ID mit
							der ID des Pakets überprüft.
						</para>
					</note>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Byzantinische Generäle</title>
		
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						Die dahinterliegende Idee ist auch bekannt als byzantinisches
						Zustimmungsproblem. Es ist nicht notwendigerweise impliziert,
						dass in einem Netzwerk ausschließlich vertrauenswürdige Peers
						vorkommen. Manchmal gibt es fehlerhafte oder bösartige Knoten.
						Diesen kann nicht vertraut werden. Es muss deshalb eine
						Möglichkeit gefunden werden weiterhin einen <quote>richtigen</quote>
						Zustand des Systems zu wahren.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Beispiel</term>
				<listitem>
					<para>
						todo
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						Als Lösung bietet sich ein Mehrheitsentscheid an. Es werden dafür
						die Aussagen mehrerer bzw aller Nachbarknoten abgewartet, bevor
						sich ein Peer für eine Option entscheidet. Trivialerweise funktioniert
						dies nur, so lange mehr Nachbarknoten die Wahrheit sagen. Ansonsten
						wird ein korrekter Knoten komprommitiert. Lamport
						bewies 1982, dass in einem System in dem alle Knoten miteinander in
						Verbindung stehen und mit <literal>k</literal> fehlerhaften
						Einheiten mindestens <literal>2k + 1</literal> korrekt funktionierende
						Einheiten vorhanden sein müssen. Die Komplexität dieses Problems
						erhöht sich jedoch für den Fall, dass nicht alle Knoten mit jedem anderen
						Knoten verbunden sind.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>		
	</section>
	
	<section>
		<title>Echo Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Idee</term>
				<listitem>
					<para>
						Der Echo Algorithmus bildet die Grundlage für
						eine Vielzahl an mögliche Anwendungen. Dazu wird
						eine Nachricht an alle Nachbarknoten geschickt, 
						welche bei Erhalt sich den Absender merken und
						die Nachricht weiterschicken. Wenn der Nachbarknoten
						schlussendlich eine Antwort von allen seinen Nachbarknoten
						erhalten hat, schickt dieser seinem <quote>Vaterknoten</quote>
						eine Antwort. <xref linkend="paper_echoalgorithm" />
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Pseudocode</term>
				<listitem>
					<variablelist>
						<varlistentry>
							<term>Schritt 1</term>
							<listitem>
								<para>
									Ein Knoten <literal>P</literal> startet den Algorithmus indem
									er folgenden Pseudo-Code ausführt.
								</para>
								<programlisting>
									<![CDATA[
										P.initiator=TRUE
										for each i from Neighbours do
											send i EXLORE
										done 
									]]>
								</programlisting>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term>Schritt 2</term>
							<listitem>
								<para>
									Folgender Pseudo-Code wird ausgeführt, wenn
									ein Knoten <literal>P</literal> die Nachricht <literal>M</literal> vom Nachbar <literal>N</literal> empfängt.
								</para>
								<programlisting>
									<![CDATA[
										function send N M :=
											send message M to neighbour M
										
										if P.state=WHITE ist AND M=EXPLORE then   
											P.state=RED
											for each i from Neighbours do
												if i!=N do
													send i EXLORE
												done
											done 
											P.parent = N
											P.received += 1
										fi
										if P.received=#(Neighbours) OR M=ECHO then
											P.state=GREEN
											if P.initiator=TRUE then
												// done
											else
												send P.parent ECHO
											fi
										fi
										wenn Anzahl == AnzahlNachbarn oder Nachricht == <echo>
											K wird grün;
											wenn K der Initiator ist
												EXIT;
											sonst
												sende <echo> an ErsterNachbar
									]]>
								</programlisting>
							</listitem>
						</varlistentry>
					</variablelist>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Anwendungsbeispiele</term>
				<listitem>
					<example>
						<para>
							Dieser Algorithmus kann sehr vielseitig eingesetzt werden.
							Zum einen kann damit ein Spannbaum eines verteilten Systems
							aufgebaut werden (siehe vorimplementiertes Demo Modul <quote>mstAlgorithm</quote>).
							Andererseits können damit auch Daten oder Anfragen in ein 
							verteiltes System realisiert werden. Der Algorithmus terminiert
							immer und ist Total da die Befragung aller Knoten aus einem verteilten System
							für die Terminierung benötigt wird. 
						</para>
					</example>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section>
		<title>Flooding Algorithmus</title>
		<variablelist>
			<varlistentry>
				<term>Problemstellung</term>
				<listitem>
					<para>
						todo
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Beispiel</term>
				<listitem>
					<para>
						todo
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Lösungsansatz</term>
				<listitem>
					<para>
						todo
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Pseudocode</term>
				<listitem>
					<para>
						todo
					</para>
				</listitem>
			</varlistentry>
		</variablelist>		
	</section>
	
</section>