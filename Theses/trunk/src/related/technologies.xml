<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook">
	<title>Technologien und Bibliotheken</title>
	<para>
		Im folgenden werden verwendete und untersuchte Technologien und Bibliotheken vorgestellt. Es wird kurz auf deren Funktionalität eingegangen und erklärt warum die Bibliothek/Technologie 
		verwendet bzw. nicht verwendet wurde.
	</para>
	<section>
		<title>Java</title>
		<figure>
			<title>Das offizielle Java Logo</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" width="60px" fileref="100px-Java-Logo.svg.png" />
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			Java ist eine objektorientierte Programmiersprache, die von Sun Microsystems entwickelt wurde. Um Java Programme zu verwenden ist eine Java-VM (Virtuelle Maschine) notwendig. Diese
			kann beispielsweise von der Sun Hompage bezogen werden. Java Programme werden in Bytecode übersetzt, welcher von dieser VM interpretiert wird. Damit benötigt man nur eine an das
			Betriebssystem bzw. an die Rechnerarchitektur angepasste VM und kann das gleiche Programm, ohne es extra übersetzten zu müssen, laufen lassen. Weitere Informationen rund um JAVA sind
			unter <xref linkend="web_java" /> zu finden.
		</para>

		<section>
			<title>Apache Ant</title>
			<figure>
			<title>Das Apache Ant Logo</title>
				<mediaobject>
					<imageobject>
						<imagedata align="center" width="100px" fileref="Ant_logo_large.gif" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Ant ist eine Werkzeug zur automatisierten Übersetzung von Java Quellcode in Bytecode. Ähnlich wie beim traditionellen Unix make wird dazu ein Buildfile benötigt. Dieses ist ein XML File in dem
				einzelne Build-Targets definiert werden können. Weiterführede Informationen über Apache Ant sind auf der Website zu finden <xref linkend="web_ant" />
			</para>
		</section>

		<section>
			<title>Java Web Start</title>
			<para>
				Java Web Start ermöglicht es Java Programme direkt mit nur einem Klick aus dem Browser zu starten. Dazu wird eine Java Network Launching Protocol (JNLP) Datei verlinkt.
				Die VM interpretiert diese Datei und ladet alle benötigten Daten herunter. Danach wird das Programm am lokalen Rechner ausgeführt <xref linkend="web_java" />.
			</para>
		</section>
		
	</section>
	
	<section>
		<title>OpenGL</title>
		<para>
			<trademark class="registered">OpenGL</trademark> steht für <quote>Open Graphics Library</quote> und ist eine öffentlich 
			spezifizierte Software-Schnittstelle für Grafik-Hardware <xref linkend="web_opengl" />. Damit ist es möglich 3-dimensionale 
			Szenen am Computerbildschirm in Echtzeit
			darzustellen. Der <trademark class="registered">OpenGL</trademark> Standard wird von einer Kommision weiterentwickelt. 
			Diese Spezifiezierungskommission heisst ARB <quote>Architecture Review Board</quote> und besteht aus Firmen wie SGI, 
			IBM, HP, Sun, Intel und ehemals Microsoft.
		</para>
		<figure>
			<title>Das <trademark class="registered">OpenGL</trademark> Logo (Quelle: <xref linkend="web_opengl" />)</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="opengl_logo.jpg" />
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			Die Biblothek entwickelte sich aus dem IRIS GL Projekt von SGI. 1992 wurde das ARB gegründet und <trademark class="registered">
			OpenGL</trademark> 1.0 veröffentlicht. Seitdem wurden ca. 8 Version herausgebracht. 2003 verließ Microsoft das ARB. Derzeit
			ist <trademark class="registered">OpenGL</trademark> 2.1  noch aktuell, die Kommission hat aber schon den 3.0 Standard (am 11. 
			August 2008) verabschiedet. Die Grafikkartenhersteller arbeiten noch an der stufenweisen Anpassung der Treiber an die neue Spezifikation
			<xref linkend="web_catalyst" />.
			<trademark class="registered">OpenGL</trademark> 3.0 hätte die erste Version werden sollen, die mit der langen Tradition der Abwärtskompatiblität
			bricht. Die Idee dahinter war es die Altlasten der vergangen Versionen zu entfernen. Allerdings wurden von den für die
			Version 3.0 vorgestellten und geplanten Änderungen viele nicht umgesetzt. Damit ist <trademark class="registered">OpenGL</trademark> 
			nach wie vor voll abwärtskompatibel <xref linkend="web_heiseopengl" />.
			Außerdem sind noch 2 weitere Versionen in Planung<xref linkend="web_siggraph" />:
		</para>
		<itemizedlist>
			<listitem>
				<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Longs Peak Reloaded</quote></para>
			</listitem>
			<listitem>
				<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Mount Evans</quote></para>
			</listitem>
		</itemizedlist>
		<para>
			<trademark class="registered">OpenGL</trademark> basiert auf einem Client/Server Modell. Es wurde so konzeptioniert, dass der Server die Renderarbeit übernimmt,
			und der Client die dazu benötigten Kommandos übermittelt. Damit muss der Client nicht zwingend am selben Rechner laufen wie der Server.
		</para>
		<para>
			Direct3D und <trademark class="registered">OpenGL</trademark> sind momentan die einzigen von den Grafikkartenherstellern
			unterstützten Bibliotheken. Direct3D, aus dem Hause Microsoft, unterstützt aber nur die Windowsplattform. <trademark class="registered">OpenGL</trademark>
			hingegen unterstützt fast alle gängigen Betriebssysteme. Da VIDIS ein plattformübergreifendes Framework ist, wurde
			<trademark class="registered">OpenGL</trademark> als Grafikbibliothek ausgewählt.
		</para>
		<figure xml:id="fig_renderpipeline">
			<title>Die <trademark class="registered">OpenGL</trademark> Fixed Function Pipeline (Quelle: <xref linkend="book_redbook" />)</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" width="100%" fileref="orderops.png" />
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			<trademark class="registered">OpenGL</trademark> hat eine fixe Funktionspipeline (<xref linkend="fig_renderpipeline"/>). Diese gibt an, wann, welche Operation 
			ausgeführt wird. Als Input erwartet sie die Vertex- bzw. Pixeldaten und am Ende der Operationen wird eine Bild in den Framebuffer geschrieben.
		</para>
		<section xml:id="section_shader">
			<title>Shader</title>
			<para>
				Shader sind vom Grafikchip ausführbare Programme, die sich in die <trademark class="registered">OpenGL</trademark> Pipeline eingliedern.	
				Mit der <trademark class="registered">OpenGL</trademark> Version 2.0 wurde die <trademark class="registered">OpenGL</trademark> Shading Language 
				(kurz GLSL) als Shadersprache eingeführt. Die Sprache besitzt eine C ähnliche Syntax sowie einige, für Vektorrechung optimierte Datentypen. 
			</para>
			<para>
				Um Shader zu verwenden benötigt man eine Grafikkarte, die Shadersupport bietet. Der Hersteller gibt dies bei den Spezifikationen als Shadermodel an. 
				Es gibt inzwischen verschiedene Versionen, aktuell ist ShaderModel 4.0. Es existieren 3 Arten von Shadern:
			</para>
			<variablelist>
				<varlistentry>
					<term>Pixel Shader / Fragment Shader</term>
					<listitem><para>
						In <trademark class="registered">OpenGL</trademark> werden sie als <quote>Fragment Shader</quote> bezeichnet, während der Begriff
						<quote>Pixel Shader</quote> aus dem Hause Microsoft kommt. Ein Pixelshader wird für jedes Pixel, bevor es in den Framebuffer 
						geschrieben wird, ausgeführt. Dabei wird die Farbe des Pixels anhand von diversen Faktoren berechnet. In der fixen Funktionspipeline ersetzen 
						Pixelshader die Fragmentoperationen (siehe <xref linkend="fig_renderpipeline" /> <quote>Per-Fragment Operations</quote>).
					</para></listitem>
				</varlistentry>
				<varlistentry>
					<term>Vertex Shader</term>
					<listitem><para>
						Vertex Shader werden per Vertex ausgeführt. Das bedeutet für jeden Vertex, der in die Grafikpipline kommt, läuft das
						Shaderprogramm einmal durch. Es kann die Position und andere Daten, die mit dem Vertex assoziert werden verändern.
						Auch Vertex Shader ersetzen einen Teil der fixen Funktionspipeline von <trademark class="registered">OpenGL</trademark>
						und zwar die Per-Vertex Operationen (<xref linkend="fig_renderpipeline" /> <quote>Per-Vertex Operations</quote>).
					</para></listitem>
				</varlistentry>
				<varlistentry>
					<term>Geometry Shader</term>
					<listitem><para>
						Geometry Shader sind die neueste Generation. Sie haben die Möglichkeit Vertices zu erzeugen und zu löschen (Ein
						Vertexshader kann das nicht, er kann nur existierende Vertices verändern). 
						Um diese Art von Shadern nutzen zu können benötigt man aktuelle Grafikhardware. Geometry Shader werden nach den 
						Vertexshadern ausgeführt (<xref linkend="fig_renderpipeline" /> <quote>Per-Vertex Operations</quote>).
					</para></listitem>
				</varlistentry>
			</variablelist>
		</section>

		<section xml:id="section_opengl_bindings">
			<title><trademark class="registered">OpenGL</trademark> Java Bindings</title>
			<para>
				Es existieren einige Projekte, die es ermöglichen den <trademark class="registered">OpenGL</trademark> Standard auch
				in anderen Sprachen wie Java zu verwenden. Einige sind einfache API-Wrapper, die über JNI einfach alle Funktionen
				der API zugänglich machen, andere haben ein komplett eigenes Objektmodell und verstecken die <trademark class="registered">
				OpenGL</trademark> API vor dem Programmierer.
			</para>
		<variablelist>
			<title>Untersuchte Java Bindings</title>
			<varlistentry>
				
				<term><trademark>Java3D</trademark></term>
				
				<listitem>
				<para>
					Die <trademark>Java3D</trademark> API ist ein Open Source Projekt. Die API setzt auf ein objektorientiertes Modell mit
					einem Szenengraph. Ein Szenengraph kann eine Szene mit all ihren Objekten, Kameraeinstellugen und Animationen beschreiben.
					Es gibt keine genaue Vorgabe wie ein Szenengraph auszusehen hat.
					Jede 3D Engine implementiert ihr eigenes Modell um bestimmte Vorgänge zu erleichtern oder zu beschleunigen. Typischerweise
					hat ein Szenengraph Transformationsknoten und Objektknoten. Ein Transformationsknoten beinhaltet eine Translations-, eine
					Rotations- oder eine Skalierungsmatrix und ein Objektknoten Vertexdaten, die das Objekt beschreiben. 
				</para><para>	
					Ein einfacher 
					Szenengraph könnte, wie <xref linkend="example_scenegraph" /> zeigt, aussehen. Der Pfad zum Objektknoten gibt
					die Reihenfolge an, in der die Matrizen verwendet werden müssen. Die Engine parst diesen Graphen und erzeugt daraus direkt 
					<trademark class="registered">OpenGL</trademark> Kommandos.
					<example xml:id="example_scenegraph">
						<title>Auszug aus einem einfachem Szenengraph</title>
						<mediaobject>
							<imageobject>
								<imagedata align="center" width="100%" fileref="scenegraph_parts2.svg" />
							</imageobject>
						</mediaobject>
					</example>	
					Der Entwickler muss sich nicht mehr direkt mit der <trademark class="registered">OpenGL</trademark> API auseinander setzen,
					sondern bearbeitet die Struktur des Szenengraphen.
				</para>
					<para>
						Der objektorientierte Ansatz von Java3D sah sehr vielversprechend aus, und deshalb war Java3D auch die erste Wahl.
						Erst nachdem der Java3D Prototyp lauffähig war, kamen die durch Java3D entstandenen Performance Einbußen ans Licht.
						Nähere Informationen dazu sind in <xref linkend="section_deadends_java3d" /> zu finden. 
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Java OpenGL (JOGL)</term>
				<listitem><para>
					JOGL<xref linkend="web_jogl" /> steht für Java OpenGL und ist die Referenzimplementation des JSR-231<xref linkend="web_jsr231" /> 
					Standards. Dieser gibt genau vor wie die <trademark class="registered">OpenGL</trademark> API Aufrufe in Java auszusehen haben.
					Prinzipiell sind alle <trademark class="registered">OpenGL</trademark> Aufrufe gleich wie in C. In Java wird jedoch eine Klasse
					verwendet, die alle Methoden und Konstanten der <trademark class="registered">OpenGL</trademark> API zur Verfügung stellt.
				</para>
				<para>
					Durch die starke Ähnlichkeit zur C Implementierung bietet JOGL einen leichten Einstieg sowohl für erfahrene als auch für 
					unerfahrene <trademark class="registered">OpenGL</trademark> Programmierer, da es reichhaltig Tutorials für OpenGL in C gibt
					<xref linkend="web_nehe" />.
				</para>
				<para>
					JOGL steht unter der Berkeley Software Distribution (BSD) Lizenz <xref linkend="web_bsd" />.
				</para>
					<para>
						Nach dem Java3D Fehlschlag waren alle objektorientierten Kanditaten aufgebraucht, und die Wahl fiel auf JOGL. 
						Nach ersten Experimenten war sicher, dass es mit JOGL weitaus
						weniger Performance Probleme geben würde. Das Unangenehme an API Wrappern wie JOGL und LWJGL ist jedoch, dass man kein
						Objektmodell hat, sondern die <trademark class="registered">OpenGL</trademark> Aufrufe alle selbst tätigen, bzw zuerst
						in eine eigene Objektstruktur packen muss. 
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Lightweight Java Gaming Library (LWJGL)</term>
				<listitem><para>
					Diese Library implementiert nicht alle Funktionen der <trademark class="registered">OpenGL</trademark> API. Die Entwickler
					haben bewusst auf veraltete und imperformate Operationen verzichtet. Dadurch hat die Bibliothek eine geringe Größe, und
					eignet sich unter anderem besonders für embedded Devices.
				</para>
					<para>
						Da es mit JOGL performancetechnisch keine Probleme gab, wurde auf einen Prototypen für LWJGL verzichtet.
					</para>
				</listitem>
			</varlistentry>

		</variablelist>
		
		</section>
	</section>


	<section xml:id="related.technologies.xml">
		<title>Extensible Markup Language (XML)</title>
		<para>
			XML wird dazu verwendet, um hierarchisch strukturierte Daten
			in Form von Textdaten abzuspeichern. Ein XML Dokument kann unterschiedliche
			Daten wie Bilder, Text oder abstraktes Wissen enthalten.
			<xref linkend="web_related.technologies.xml"/>
		</para>
		
		<section xml:id="compare_xml_sax_dom">
			<title>Vergleich XML Parser: DOM vs. SAX</title>
			<para>
				Im folgenden werden die Vor- und Nachteile der
				zwei gebräuchlichsten XML
				Parser behandelt.
			</para>
			<variablelist>
				<varlistentry>
					<term>DOM</term>
					<listitem>
						<para>
							Ein DOM Parser erstellt einen Baum des XML-Dokumentes
							um auf die Daten darin zuzugreifen. Ein großer Vorteil
							dabei ist, dass der Zugriff sehr einfach ist. Jedoch
							muss das gesamte Dokument zuvor eingelesen werden. Dies
							kann bei sehr großen Dokumenten zu Speicherproblemen oder
							sogar Systeminstabilität führen.
						</para>
						<para>
							Die Komplexität und der zeitliche Aufwand
							der Implementierung eines DOM Parsers ist sehr viel
							geringer als die eines SAX Parsers. Jedoch ist ein
							DOM Parser nicht für große Dokumente, sequentielle Daten und
							große Datenmengen geeignet, da das gesamte Dokument geladen
							werden muss. Auch bei Dokumenten, welche in sich sehr verschachtelt
							und verlinkt sind, ist ein DOM Parser zu bevorzugen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>SAX</term>
					<listitem>
						<para>
							Ein SAX Parser liest das XML Dokument als sequentiellen
							Datenstrom ein und verarbeitet XML Knoten dynamisch. Dies
							birgt den Vorteil, dass sequentielle Daten schnell eingelesen
							und verarbeitet werden können und anschließend nicht benötigter
							Speicher wieder freigegeben werden kann. In diesen Fällen können
							durch große Dokumente bedingte Ressourcenprobleme vermieden werden. 
						</para>
						<para>
							Ein SAX Parser ist für große Dokumente, sequentielle Daten
							und große Datenmengen zu bevorzugen. Nicht geeignet ist 
							ein SAX Parser für in sich stark verschachtelte Datenstrukturen.
							Zum Beispiel wenn einzelne Elemente mehrfach quer durch das ganze
							Dokument verlinkt werden. In diesen Fällen kann der
							Vorteil durch das sequentielle Parsen zum Parsen in einem 
							DOM Baum degenerieren. 
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
		
		<section xml:id="related.technologies.docbook">
			<title>DocBook</title>
			<para>
				DocBook eignet sich zum Schreiben von Büchern, Artikeln
				und Dokumentationen im Informatikbereich. Die Technik
				basiert auf XSL Transformationen eines DocBook-DTD
				konformen Dokumentes. Damit ist DocBook sehr vielseitig
				einsetzbar und erleichtert das Schreiben von technischen
				Texten. Diese Bakkalaureatsarbeit wurde in DocBook
				verfasst. DocBook ist aber auch in OpenSource Projekten
				weit verbreitet.
				<xref linkend="web_related.technologies.docbook"/>
			</para>
		</section>

		<section xml:id="related.technologies.fop">
			<title>FOP</title>
			<para>
				FOP, oder auch Formatting Objects Processor ist ein Programm
				zur Verarbeitung von XSL-FO Dokumenten. Wie in <xref linkend="related.technologies.docbook"/>
				beschrieben, haben wir DocBook zum Schreiben dieser
				Bakkalaureatsarbeit verwendet. Mit Hilfe von FOP wurde
				diese Arbeit im DocBook Format mittels XSL-Transformationen
				in das vorliegende Format umgewandelt. FOP unterstützt auch
				Formate wie PDF, Java2D/AWT, AFP, PCL, MIF, PS, RTF, TIFF,
				PNG, SVG und TXT. Es ist auch möglich das Dokument direkt an einen
				angeschlossenen Drucker zu senden oder die Ausgabe des 
				internen Strukturbaums im XML Format.
				<xref linkend="web_related.technologies.fop"/>
			</para>
		</section>
		
	</section>

</section>
