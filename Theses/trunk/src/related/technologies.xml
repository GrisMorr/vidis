<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook">
	<title>Technologien und Bibliotheken</title>
	<para></para>

	<section>
		<title>Java</title>
		<para></para>

		<section>
			<title>Ant</title>
			<para></para>
		</section>

		<section>
			<title>Java WebStart</title>
			<para></para>
		</section>
		
	</section>
	
	<section>
		<title>OpenGL</title>
		<para>
			<trademark class="registered">OpenGL</trademark> steht für <quote>Open Graphics Library</quote> und ist eine öffentlich 
			spezifizierte<footnote><para>Die Spezifikation ist unter <xref linkend="web_opengl" /> zu finden.</para></footnote> 
			Software-Schnittstelle für Grafik-Hardware. Die Spezifiezierungskommission besteht aus Firmen wie SGI, IBM, HP, Sun, Intel
			und Microsoft.
		</para>
		<figure>
			<title>Das <trademark class="registered">OpenGL</trademark> Logo (Quelle: <xref linkend="web_opengl" />)</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="opengl_logo.jpg" />
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			<trademark class="registered">OpenGL</trademark> 2.1 ist derzeit noch aktuell, die Kommission hat den 3.0 Standard am 11. 
			August 2008 verabschiedet. Derzeit arbeiten die Grafikkartenhersteller noch an der Anpassung der Treiber an die neue Spezifikation
			<xref linkend="web_catalyst" />.
			<trademark class="registered">OpenGL</trademark> 3.0 hätte die erste Version, die mit der langen Tradition der Abwärtskompatiblität
			bricht, werden sollen. Die Idee dahinter war es die Altlasten der vergangen Versionen zu entfernen. Allerdings wurden von den für die
			Version 3.0 vorgestellten und geplanten Änderungen viele nicht umgesetzt. Damit ist <trademark class="registered">OpenGL</trademark> 
			nach wie vor voll abwärtskompatibel <xref linkend="web_heiseopengl" />.
		</para>
		<para>
			Außerdem sind noch 2 weitere Versionen in Planung<xref linkend="web_siggraph" />:
			<itemizedlist>
				<listitem>
					<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Longs Peak Reloaded</quote></para>
				</listitem>
				<listitem>
					<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Mount Evans</quote></para>
				</listitem>
			</itemizedlist>
		</para>
		<section>
			<title><trademark class="registered">OpenGL</trademark> Java Bindings</title>
			<para>
				Es existieren einige Projekte, die es ermöglichen den <trademark class="registered">OpenGL</trademark> Standard auch
				in anderen Sprachen wie zb Java zu verwenden. Einige sind einfache API-Wrapper, die über JNI einach alle Funktionen
				der API zugänglich machen, andere haben ein komplett eigenes Objektmodell und verstecken die <trademark class="registered">
				OpenGL</trademark> API vor dem Programmierer.
			</para>
		<variablelist>
			<title>Untersuchte Java Bindings</title>
			<varlistentry>
				
				<term><trademark>Java3D</trademark></term>
				
				<listitem>
				<para>
					Die <trademark>Java3D</trademark> API ist ein Open Source Projekt. Die API setzt auf ein objektorientiertes Modell mit
					einem Szenengraph. Ein Szenengraph kann eine Szene mit all ihren Objekten, Kameraeinstellugen und Animationen beschreiben.
					Es gibt keine genaue Vorgabe wie ein Szenengraph auszusehen hat.
					Jede 3D Engine implementiert ihr eigenes Modell um bestimmte Vorgänge zu erleichtern oder zu beschleunigen. Typischerweise
					hat ein Szenengraph Transformationsknoten und Objektknoten. Ein Transformationsknoten beinhaltet eine Translations-, eine
					Rotations- oder eine Skalierungsmatrix und ein Objektknoten Vertexdaten, die das Objekt beschreiben. 
				</para><para>	
					Ein einfacher 
					Szenengraph könnte, wie <xref linkend="example_scenegraph" /> zeigt, aussehen. Der Pfad vom Rootknoten zum Objektknoten gibt
					die Reihenfolge an, in der die Matrizen verwendet werden müssen. Die Engine parst diesen Graphen und erzeugt daraus direkt 
					<trademark class="registered">OpenGL</trademark> Kommandos.

					<example id="example_scenegraph">
						<title>Auszug aus einem einfachem Szenengraph</title>
						<programlisting>
							+ Root-Knoten
							|-+ Translations-Knoten
							| |-+ Rotations-Knoten
							| | |-+ Objekt-Knoten
						</programlisting>
					</example> 
					
					Der Entwickler muss sich nicht mehr direkt mit der <trademark class="registered">OpenGL</trademark> API auseinander setzen,
					sondern bearbeitet die Struktur des Szenengraphen.
				</para></listitem>
			</varlistentry>

			<varlistentry>
				<term>Java OpenGL (JOGL)</term>
				<listitem><para>
					JOGL<xref linkend="web_jogl" /> steht für Java OpenGL und implementiert den JSR-231<xref linkend="web_jsr231" /> Standard.
					Dieser gibt genau vor wie die <trademark class="registered">OpenGL</trademark> API Aufrufe in Java auszusehen haben.
				</para></listitem>
			</varlistentry>

			<varlistentry>
				<term>Lightweight Java Gaming Library (LWJGL)</term>
				<listitem><para>
					Diese Library implementiert nicht alle Funktionen der <trademark class="registered">OpenGL</trademark> API. Die Entwickler
					haben bewusst auf veraltete und imperformate Operatinen verzichtet. Dadurch hat die Bibliothek eine geringe Größe, und
					eignet sich unter anderem besonders für embedded Devices.
				</para></listitem>
			</varlistentry>>

		</variablelist>
		</section>
	</section>


	<section>
		<title>XML</title>
		<para>
			Im folgenden behandeln wir die Vor- und Nachteile der
			<quote>Extensible Markup Language</quote>.
		</para>
		
		<section id="compare_xml_sax_dom">
			<title>Vergleich XML Parser: DOM vs. SAX</title>
			<para>
				DOM ist cool. SAX ist cooler.
			</para>
			<para>TODO</para>
		</section>
		
		<section>
			<title>DocBook</title>
			<para></para>
		</section>

		<section>
			<title>FOP</title>
			<para></para>
		</section>
		
	</section>

</section>
