<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook">
	<title>Technologien und Bibliotheken</title>
	<para></para>

	<section>
		<title>Java</title>
		<para></para>

		<section>
			<title>Ant</title>
			<para></para>
		</section>

		<section>
			<title>Java WebStart</title>
			<para></para>
		</section>
		
	</section>
	
	<section>
		<title>OpenGL</title>
		<para>
			<trademark class="registered">OpenGL</trademark> steht für <quote>Open Graphics Library</quote> und ist eine öffentlich 
			spezifizierte<footnote><para>Die Spezifikation ist unter <xref linkend="web_opengl" /> zu finden.</para></footnote> 
			Software-Schnittstelle für Grafik-Hardware. Die Spezifiezierungskommission besteht aus Firmen wie SGI, IBM, HP, Sun, Intel
			und Microsoft.
		
		<figure>
			<title>Das <trademark class="registered">OpenGL</trademark> Logo (Quelle: <xref linkend="web_opengl" />)</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="opengl_logo.jpg" />
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			<trademark class="registered">OpenGL</trademark> 2.1 ist derzeit noch aktuell, die Kommission hat den 3.0 Standard am 11. 
			August 2008 verabschiedet. Derzeit arbeiten die Grafikkartenhersteller noch an der Anpassung der Treiber an die neue Spezifikation
			<xref linkend="web_catalyst" />.
			<trademark class="registered">OpenGL</trademark> 3.0 hätte die erste Version, die mit der langen Tradition der Abwärtskompatiblität
			bricht, werden sollen. Die Idee dahinter war es die Altlasten der vergangen Versionen zu entfernen. Allerdings wurden von den für die
			Version 3.0 vorgestellten und geplanten Änderungen viele nicht umgesetzt. Damit ist <trademark class="registered">OpenGL</trademark> 
			nach wie vor voll abwärtskompatibel <xref linkend="web_heiseopengl" />.
			Außerdem sind noch 2 weitere Versionen in Planung<xref linkend="web_siggraph" />:
		</para>
		<itemizedlist>
			<listitem>
				<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Longs Peak Reloaded</quote></para>
			</listitem>
			<listitem>
				<para><trademark class="registered">OpenGL</trademark> 3.x <quote>Mount Evans</quote></para>
			</listitem>
		</itemizedlist>
		<section>
			<title><trademark class="registered">OpenGL</trademark> Java Bindings</title>
			<para>
				Es existieren einige Projekte, die es ermöglichen den <trademark class="registered">OpenGL</trademark> Standard auch
				in anderen Sprachen wie zb Java zu verwenden. Einige sind einfache API-Wrapper, die über JNI einach alle Funktionen
				der API zugänglich machen, andere haben ein komplett eigenes Objektmodell und verstecken die <trademark class="registered">
				OpenGL</trademark> API vor dem Programmierer.
			</para>
		<variablelist>
			<title>Untersuchte Java Bindings</title>
			<varlistentry>
				
				<term><trademark>Java3D</trademark></term>
				
				<listitem>
				<para>
					Die <trademark>Java3D</trademark> API ist ein Open Source Projekt. Die API setzt auf ein objektorientiertes Modell mit
					einem Szenengraph. Ein Szenengraph kann eine Szene mit all ihren Objekten, Kameraeinstellugen und Animationen beschreiben.
					Es gibt keine genaue Vorgabe wie ein Szenengraph auszusehen hat.
					Jede 3D Engine implementiert ihr eigenes Modell um bestimmte Vorgänge zu erleichtern oder zu beschleunigen. Typischerweise
					hat ein Szenengraph Transformationsknoten und Objektknoten. Ein Transformationsknoten beinhaltet eine Translations-, eine
					Rotations- oder eine Skalierungsmatrix und ein Objektknoten Vertexdaten, die das Objekt beschreiben. 
				</para><para>	
					Ein einfacher 
					Szenengraph könnte, wie <xref linkend="example_scenegraph" /> zeigt, aussehen. Der Pfad vom Rootknoten zum Objektknoten gibt
					die Reihenfolge an, in der die Matrizen verwendet werden müssen. Die Engine parst diesen Graphen und erzeugt daraus direkt 
					<trademark class="registered">OpenGL</trademark> Kommandos.

					<example id="example_scenegraph">
						<title>Auszug aus einem einfachem Szenengraph</title>
						<programlisting>
							+ Root-Knoten
							|-+ Translations-Knoten
							| |-+ Rotations-Knoten
							| | |-+ Objekt-Knoten
						</programlisting>
					</example> 
					
					Der Entwickler muss sich nicht mehr direkt mit der <trademark class="registered">OpenGL</trademark> API auseinander setzen,
					sondern bearbeitet die Struktur des Szenengraphen.
				</para></listitem>
			</varlistentry>

			<varlistentry>
				<term>Java OpenGL (JOGL)</term>
				<listitem><para>
					JOGL<xref linkend="web_jogl" /> steht für Java OpenGL und ist die Referenzimplementation des JSR-231<xref linkend="web_jsr231" /> 
					Standards. Dieser gibt genau vor wie die <trademark class="registered">OpenGL</trademark> API Aufrufe in Java auszusehen haben.
					Prinzipiell sind alle <trademark class="registered">OpenGL</trademark> Aufrufe gleich wie in C. In Java wird jedoch eine Klasse
					verwendet, die alle Methoden und Konstanten der <trademark class="registered">OpenGL</trademark> API zur Verfügung stellt.
				</para>
				<para>
					Durch die starke Ähnlichkeit zur C Implementierung bietet JOGL einen leichten Einstieg sowohl für erfahrene als auch für 
					unerfahrene <trademark class="registered">OpenGL</trademark> Programmierer, da es reichhaltig Tutorials für OpenGL in C gibt
					<xref linkend="web_nehe" />.
				</para>
				<para>
					JOGL steht unter der BSD<footnote><para>Berkeley Software Distribution License<xref linkend="web_bsd" /></para></footnote> 
					Linzenz. 
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Lightweight Java Gaming Library (LWJGL)</term>
				<listitem><para>
					Diese Library implementiert nicht alle Funktionen der <trademark class="registered">OpenGL</trademark> API. Die Entwickler
					haben bewusst auf veraltete und imperformate Operatinen verzichtet. Dadurch hat die Bibliothek eine geringe Größe, und
					eignet sich unter anderem besonders für embedded Devices.
				</para></listitem>
			</varlistentry>>

		</variablelist>
		</section>
	</section>


	<section id="related.technologies.xml">
		<title>XML</title>
		<para>
			XML wird dazu verwendet, um hierarchisch strukturierte Daten
			in Form von Textdaten abzuspeichern. Ein XML Dokument kann unterschiedliche
			Daten wie Bilder, Text oder abstraktes Wissen enthalten.
			(Quelle: <xref linkend="web_related.technologies.xml"/>)
		</para>
		
		<section id="compare_xml_sax_dom">
			<title>Vergleich XML Parser: DOM vs. SAX</title>
			<para>
				Im folgenden werden die Vor- und Nachteile der
				<quote>Extensible Markup Language</quote> behandelt.
			</para>
			<variablelist>
				<title>Vergleich DOM/SAX Parser</title>
				<varlistentry>
					<term>DOM</term>
					<listitem>
						<para>
							Ein DOM Parser erstellt einen Baum des XML-Dokumentes
							um auf die Daten darin zuzugreifen. Ein großer Vorteil
							dabei ist, dass der Zugriff sehr einfach ist. Jedoch
							muss das gesamte Dokument zuvor eingelesen werden. Dies
							kann bei sehr großen Dokumenten zu Speicherproblemen oder
							sogar Systeminstabilität führen.
						</para>
						<para>
							Die Komplexität und der zeitliche Aufwand
							der Implementierung eines DOM Parsers ist sehr viel
							geringer als die eines SAX Parsers. Jedoch ist ein
							DOM Parser nicht für große Dokumente, sequentielle Daten und
							große Datenmengen geeignet, da das gesamte Dokument geladen
							werden muss. Auch bei Dokumenten, welche in sich sehr verschachtelt
							und verlinkt sind, ist ein DOM Parser zu bevorzugen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>SAX</term>
					<listitem>
						<para>
							Ein SAX Parser liest das XML Dokument als sequentiellen
							Datenstrom ein und verarbeitet XML Knoten dynamisch. Dies
							birgt den Vorteil, dass sequentielle Daten schnell eingelesen
							und verarbeitet werden können und anschließend nicht benötigter
							Speicher wieder freigegeben werden kann. In diesen Fällen können
							durch große Dokumente bedingte Ressourcenprobleme vermieden werden. 
						</para>
						<para>
							Ein SAX Parser ist für große Dokumente, sequentielle Daten
							und große Datenmengen zu bevorzugen. Nicht geeignet ist 
							ein SAX Parser für in sich stark verschachtelte Datenstrukturen.
							So z.B. wenn einzelne Elemente mehrfach quer durch das ganze
							Dokument verlinkt werden. In diesen Fällen kann der
							Vorteil durch das sequentielle Parsen zum Parsen in einem 
							DOM Baum degenieren. 
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
		
		<section id="related.technologies.docbook">
			<title>DocBook</title>
			<para>
				DocBook eignet sich zum Schreiben von Büchern, Artikeln
				und Dokumentationen im Informatikbereich. Die Technik
				basiert auf XSL Transformationen eines DocBook-DTD
				konformen Dokumentes. Damit ist DocBook sehr vielseitig
				einsetzbar und erleichtert das Schreiben von technischen
				Texten. Diese Bakkalaureatsarbeit wurde in DocBook
				verfasst. DocBook ist aber auch in OpenSource Projekten
				weit verbreitet.
				(Quelle: <xref linkend="web_related.technologies.docbook"/>)
			</para>
		</section>

		<section id="related.technologies.fop">
			<title>FOP</title>
			<para>
				FOP, oder auch Formatting Objects Processor ist ein Programm
				zur Verarbeitung von XSL-FO Dokumenten. Wie in <xref endpoint="related.technologies.docbook"/>
				beschrieben, haben wir DocBook zum Schreiben dieser
				Bakkalaureatsarbeit verwendet. Mit Hilfe von FOP wurde
				diese Arbeit im DocBook Format mittels XSL-Transformationen
				in das vorliegende Format umgewandelt. FOP unterstützt aber
				Formate wie PDF, Java2D/AWT, AFP, PCL, MIF, PS, RTF, TIFF,
				PNG, SVG und TXT. Es ist auch möglich das Dokument direkt an einen
				angeschlossenen Drucker zu senden oder die Ausgabe des 
				internen Strukturbaums im XML Format.
				(Quelle: <xref linkend="web_related.technologies.fop"/>)
			</para>
		</section>
		
	</section>

</section>
