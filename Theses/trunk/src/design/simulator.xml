<?xml version="1.0" encoding="UTF-8"?>
<section
	xmlns="http://docbook.org/ns/docbook">
	<title>Simulator</title>
	<section>
		<title>Definitionen</title>
		<para>
			Folgende Definitionen werden im Simulator verwendet.
		</para>
		<section>
			<title>Komponente</title>
			<para>
				Wir bezeichnen eine Komponente als eine ausführbare, vom Benutzer implementierte Klasse.
			</para>
			<para>
				Es wird unter folgenden Komponententypen unterschieden:
			</para>
			<section>
				<title>Node</title>
				<para>
					Ein Node, oder auch <quote>Knoten</quote>, ist in der Terminologie gleichzusetzen mit einem Peer aus einem Verteilten Systemen.
				</para>
				<para>
					In einem Netzwerk aus Computern wäre ein Knoten einer dieser Rechner.
				</para>
				<para>
					Ein Knoten kann sich über Links mit anderen Knoten verbinden und so mit diesen über Pakete kommunizieren.
				</para>
				<para>
					Mehr Informationen zum Interface eines
					Modul Nodes findet man im Abschnitt
					<xref linkend="design.module.node" />.
				</para>
				<para>
					Mehr Informationen zur implementierten Funktionalität eines Knoten findet man im Abschnitt <xref linkend="implementation.module.node" /><!-- xlink:to "Implementation > Modul > Node"/xlink:to -->.
				</para>
			</section>
			<section>
				<title>Link</title>
				<para>
					Ein Link, oder auch <quote>Verbindung</quote>, ist in der Terminologie gleichzusetzen mit einer aktiven Verbindung zwischen zwei Peers aus einem Verteilten System.
				</para>
				<para>
					Mehr Informationen zum Interface eines
					Modul Links findet man im Abschnitt
					<xref linkend="design.module.link" />.
				</para>
				<para>
					Mehr Informationen zur implementierten Funktionalität eines Links findet man im Abschnitt <xref linkend="implementation.module.link" /><!-- xlink:to"Implementation > Modul > Link" /xlink:to -->.
				</para>
			</section>
			<section>
				<title>Packet</title>
				<para>
					Ein Packet, oder auch <quote>Paket</quote> ist in der Terminologie gleichzusetzen mit einem Datenpaket das über eine aktive Verbindung zwischen zwei Peers geschickt wird.
				</para>
				<para>
					Mehr Informationen zum Interface eines
					Modul Pakets findet man im Abschnitt
					<xref linkend="design.module.packet" />.
				</para>
				<para>
					Mehr Informationen zur implementierten Funktionalität eines Pakets findet man im Abschnitt <xref linkend="implementation.module.packet" /><!-- xlink:to"Implementation > Modul > Paket" -->.
				</para>
			</section>
		</section>
		<section>
			<title>Modul</title>
			<para>Ein Modul ist eine Menge aus Komponenten</para>
		</section>
		<section>
			<title>Steps</title>
			<para>
				Ein <quote>Step</quote>, oder auch <quote>Schritt</quote> ist die kleinste Zeiteinheit im Simulator.
			</para>
		</section>
	</section>
	<section>
		<title>Funktionsweise</title>
		<para>
			Der Simulator ist die ausführende Einheit eines Moduls.
			Dieser hat folgende wesentlichen Aufgaben:
			<itemizedlist>
				<listitem>Modul laden</listitem>
				<listitem>Objekte instantiieren</listitem>
				<listitem>Schrittweise simulieren</listitem>
			</itemizedlist>
		</para>
		<para>
			Nach jedem Simulationsschritt werden alle Veränderungen an
			den Objektinstanzen des geladenen Moduls an die Visualisierung
			weitergegeben.
		</para>
		<section>
			<title>Modul laden</title>
			<para>
				In diesem Kapitel wird die Funktionalität <quote>Modul laden</quote>
				definiert.
			</para>
			<para>
				Der Simulator soll die Funktion
				<methodsynopsis>
					<methodname>importSimFile</methodname>
					<methodparam>
						<type>IModuleFileComponent</type>
						<parameter>simFile</parameter>
					</methodparam>
				</methodsynopsis> implementieren um eine MSIM-Datei
				zu importieren.
			</para>
			<para>
				Das Interface 
				<classsynopsis>
					<oointerface>
						<package>vidis.sim.classloader.modules.interfaces</package>
						<modifier>public</modifier>
						<interfacename>IModuleFileComponent</interfacename>
					</oointerface>
				</classsynopsis>
				beschreibt eine MSIM-Datei und definiert folgende Funktionen:
				<itemizedlist>
					<listitem>
							Diese Funktion öffnet einen InputStream zur MSIM-Datei
							welche diese Klasse repräsentiert.
						<methodsynopsis>
							<modifier>public</modifier>
							<type>InputStream</type>
							<methodname>getInputStream</methodname>
							<void/>
							<exceptionname>IOException</exceptionname>
						</methodsynopsis>
					</listitem>
					<listitem>
							Diese Funktion gibt den Namen dieser MSIM-Datei zurück.
							Dies kann der Dateiname, aber auch ein Bezeichner aus einer
							Meta-Information eines Jar-Archivs sein.
						<methodsynopsis>
							<modifier>public</modifier>
							<type>String</type>
							<methodname>getName</methodname>
							<void/>
						</methodsynopsis>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Anschließend soll der Simulator versuchen, die Datei zu öffnen
				und den Inhalt mittels eines InputStream's einzulesen. Dieser
				InputStream soll dazu einem XML Parser übergeben werden, welcher
				die Datei analysiert und alle wichtigen Informationen extrahiert.
				Für XML	gibt es zwei Möglichkeiten eine Datei zu parsen:
				<itemizedlist>
					<listitem>DOM</listitem>
					<listitem>SAX</listitem>
				</itemizedlist>
			</para>
			<para>
				Ein DOM Parser liest das Dokument als Ganzes ein und 
				baut daraus einen DOM-Tree über welchen man auf die 
				Objekte zugreifen kann.
			</para>
			<para>
				Ein SAX Parser liest das Dokument über den Stream ein
				und reagiert auf das Öffnen und Schließen eines Tags.
			</para>
			<note>
				<para>
					Ein Vergleich der Technologien befindet sich hier:
					<xref linkend="compare_xml_sax_dom" />
				</para>
			</note>
			<para>
				Da die Vorteile eines DOM Parsers für unsere Anwendung
				überwiegen, haben wir uns dafür entschieden diesen zu
				verwenden.
			</para>
		</section>
	</section>
	<section>
		<title>Player</title>
		<para>Der Player ist die kontrollierende Einheit für den 
		Simulator. Er kümmert sich darum, einen Simulationsschritt
		anzustossen. Somit ist er das Verbindungsstück zwischen 
		Simulation und Visualisierung.</para>
		<para>
			Der Player hat mehrere Zustände. Im folgenden
			werden diese Zustände erläutert.
			<itemizedlist>
				<listitem>
						Ist der Simulator nicht gestoppt, kodiert dieser
						Zustand ob ein weiterer Simulationsschritt
						ausgeführt werden soll.
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>paused</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
						In diesem Zustand ist der Simulator gestoppt,
						das Modul neu geladen, die Objekte richtig
						instantiiert und der Simulator bereit zu starten.
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>stopped</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
						Kodiert den Zustand des korrekten Beendens
						des Simulators.
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>killed</varname>
					</fieldsynopsis>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			Folgendes Zustandübergangsdiagramm veranschaulicht die Zustandsmaschine
			Player.
		</para>
		<figure>
			<title>Zustandsübergangsdiagramm des Players</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="figures/zustandsübergangsdiagramm-player.png" width="400" align="center">
					</imagedata>
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			Er implementiert folgende Funktionalität:
			<itemizedlist>
				<listitem>
						Diese Funktion startet den Simulator falls
						er noch nicht gestartet wurde. Wurde der Simulator
						bereits gestartet, hat diese Funktion keinen Effekt.
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>play</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
						Diese Funktion pausiert den Simulator. Wurde der Simulator
						bereits pausiert, startet diese Funktion den Simulator.
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>pause</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
						Diese Funktion startet bzw stoppt den Simulator.
						Wurde der Simulator gestoppt, ruft diese Funktion
						play() auf. Wurde der Simulator hingegen nicht
						gestoppt, ruft diese Funktion pause() auf.
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>playPause</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
						Diese Funktion stoppt den Simulator. Ist der Simulator
						bereits gestoppt hat ein Aufruf dieser Funktion keine
						Auswirkung.
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>stop</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<para>
						Diese Funktion veranlasst den Simulator dazu,
						alle allokierten Ressourcen freizugeben und
						erlaubt dem Player-Thread zu sterben.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>kill</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>Datenstruktur (intern)</title>
		<para>
			<phrase>Die Datenstruktur des Simulators ist ein Tupel
			(M, t), wobei M die Menge der ausführbaren Komponenten ist
			und t der aktuelle Simulationsschritt ist.</phrase>
		</para>
		<para>
			Diese Datenstruktur ist in der Klasse SimulatorData implementiert.
			Die Klasse enthält die Felder:
			<itemizedlist>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>long</type>
						<varname>now</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>List&lt;AComponent&gt;</type>
						<varname>components</varname>
					</fieldsynopsis>
				</listitem>
			</itemizedlist>
			Die Klasse enthält im Wesentlichen diese Funktionen:
			<itemizedlist>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>long</type>
						<methodname>getTime</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>registerComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>unregisterComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>executeComponents</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
			</itemizedlist>
		</para>
	</section>
</section>