<?xml version="1.0" encoding="UTF-8"?>
<section
	xmlns="http://docbook.org/ns/docbook"
	xml:id="design.simulator">
	<title>Simulatordesign</title>
	<para>
		Im folgenden Kapitel wird die Idee und das Design
		des Simulators besprochen. Dazu wird zunächst der
		Grundgedanke erörtert, wie ein Verteiltes System
		simuliert werden kann. Anschließend werden die 
		für VIDIS wichtigen Komponenten bestimmt und 
		analysiert wie diese umgesetzt werden können.
		Schlussendlich wird die Umsetzungsidee mittels
		Interfaces und Methodenköpfe dargelegt.
	</para>
	<section>
		<title>Simulation von verteilten Systemen</title>
		<para>
			In diesem Kapitel werden die Eigenschaften von den
			am häufigsten vorkommenden verteilten Systemen
			analysiert. Diese Grundlage wird daraufhin
			verwendet um einen groben Grundriss über die
			Idee hinter VIDIS zu skizzieren.
		</para>
		<para>
			Verteilte Systeme bestehen sehr häufig aus einer
			Menge von Rechnern welche auch Peers genannt werden.
			Diese können miteinander über ein Netzwerk
			kommunizieren. Dabei kann es vorkommen, dass Peers
			durch Subnetze getrennt nicht direkt miteinander kommunizieren
			können. Es kann aber durchaus sein, dass dies durch die 
			Hilfe eines Peers der mit den zwei anderen kommunizieren kann,
			möglich ist. In diesen Fällen spricht man von <quote>Message Forwarding</quote>.
			Die Kommunikation zwischen einzelnen Peers erfolgt 
			großteils über Datenpakete, welche über eine Netzwerkleitung
			übertragen werden.
		</para>
		<para>
			Bei der Übertragung kommt es immer
			zu Verzögerungen, welche auch als <literal>Latenz</literal>
			bezeichnet werden. Grund dafür ist die Verzögerung von Schaltungen
			, die Länge des Leiters und die Einschränkung
			der Bandbreite einer Leitung. Es gibt zwar verschiedenste Arten von Leitungen.
			Die bekanntesten darunter sind elektrische Leitungen. Weitere
			Arten sind funkgetriebene oder auch optische Leiter. Für VIDIS spielen
			diese aber keine Rolle.
		</para>
		<para>
			Ausgehend von diesen Beobachtungen wurden folgende
			drei Basiskomponenten identifiziert, welche für eine 
			für VIDIS möglichst optimale Simulation erforderlich sind.
		</para>
		<variablelist xml:id="design.simulator.simulatorkomponenten">
			<title>Simulator Komponenten</title>
			<varlistentry xml:id="design.simulator.knoten">
				<term>Knoten</term>
				<listitem>
					<para>
						Dieser repräsentiert einen Rechner in
						einem verteilten System und soll die
						Fähigkeit besitzen mit anderen Knoten zu
						kommunizieren. Die Kommunikation erfolgt
						mittels Pakete, welche über eine Verbindung
						von einem zum anderen Knoten übertragen wird
						und dann vom Empfänger verarbeitet werden kann.
						Weiters soll ein Knoten eine proprietäre Funktionalität
						implementieren können, welche unabhängig vom
						Nachrichtensystem iterativ ausgeführt wird.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry xml:id="design.simulator.paket">
				<term>Paket</term>
				<listitem>
					<para>
						Mit Hilfe eines Pakets soll es möglich 
						sein Daten von einem Knoten zu einem anderen
						Knoten zu übertragen. Das Paket soll beliebige
						Daten enthalten können.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry xml:id="design.simulator.verbindung">
				<term>Verbindung</term>
				<listitem>
					<para>
						Um ein Netzwerk aus Knoten realisieren zu
						können wird eine Komponente benötigt, welche
						die Verbindung zwischen zwei Knoten repräsentiert.
						Diese Komponente muss auch den Transport
						von Paketen von einem Knoten zu einem anderen
						simulieren können.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Da das primäre Einsatzgebiet von VIDIS nicht eine
			genaue Widergabe der Realität erfordert, wurden
			folgende Aspekte nicht in Betracht bezogen.
		</para>
		<variablelist>
			<varlistentry>
				<term>Knoten</term>
				<listitem>
					<para>
						TODO: gibts hier was das man erwähnen könnte?
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Paket</term>
				<listitem>
					<para>
						TODO: gibts hier was das man erwähnen könnte?
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Verbindung</term>
				<listitem>
					<para>
						Eine Verbindung soll zwar die Latenz simulieren,
						jedoch nicht eine Bandbreitenlimitierung. Da 
						VIDIS kein Netzwerksimulator wie <quote>NAM</quote>
						der <quote>Network Animator</quote> und dieser Aspekt
						für die Visualisierung der Funktionsweise von den
						meisten Algorithmen irrelevant ist, wurde die Bandbreitenlimitierung
						nicht in den Simulator eingeplant.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Durch den modularen und sehr flexiblen Aufbau
			der Klassenstrukturen ist es dennoch möglich
			diese Aspekte im Rahmen eines Moduls zu implementieren
			(vgl. <xref linkend="conclusions.futurework.linkbandwidth" />).
		</para>
	</section>
	<section>
		<title>Umsetzung</title>
		<para>
			Im vorhergehenden Kapitel wurde die Grundidee
			des Simulators beschrieben und skizziert. In
			diesem Kapitel wird die Umsetzung dieser Idee
			skizziert. Dieses Kapitel soll eine Übersicht
			über die Komponenten des Simulators, die 
			Komponenten eines Moduls und deren Funktionsweise
			bieten.
		</para>
		<section>
			<title>Simulator Komponenten</title>
			<para>
				Als eine Simulator Komponente wird eine
				für den Benutzer nicht sichtbare Repräsentation
				einer ausführbaren Einheit bezeichnet. Diese
				kann verschiedene Rollen übernehmen. Es wurde
				eingehend erörtert welche Komponenten die
				Simulation eines Großteils von verteilten Systemen
				ermöglichen. Folgende Basiskomponenten werden
				in dieser Arbeit unterschieden und sind für VIDIS
				von Relevanz:
			</para>
			<variablelist>
				<varlistentry xml:id="design.simulator.simulatornode">
					<term>Simulator Node</term>
					<listitem>
						<para>
							Dies ist die simulatorinterne Repräsentation
							eines in Knotens (vgl. <xref linkend="design.simulator.knoten" />)
							und implementiert die nötige Funktionalität (vgl. <xref linkend="implementation.module.node" />) um
							einen Modul Node (vgl. <xref linkend="design.module.node" />) in sich zu integrieren.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry xml:id="design.simulator.simulatorlink">
					<term>Simulator Link</term>
					<listitem>
						<para>
							Ein Link, oder auch <quote>Verbindung</quote>,
							ist die simulatorinterne Darstellung einer
							Verbindung (vgl. <xref linkend="design.simulator.verbindung" />).
							Informationen über die implementierte Funktionalität
							befinden sich in <xref linkend="implementation.module.link" />.
							Diese Komponente kann einen Modul Link <xref linkend="design.module.link" />
							in sich integrieren.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry xml:id="design.simulator.simulatorpacket">
					<term>Simulator Packet</term>
					<listitem>
						<para>
							Mit einem Simulator Packet bezeichnen wir in dieser Arbeit
							die simulatorinterne Repräsentation für ein Paket (vgl. <xref linkend="design.simulator.paket" />).
							Sinngemäß entspricht es in der Terminologie verteilter
							Systeme einem Datenpaket das über eine aktive Verbindung
							zwischen zwei Peers übertragen wird. Ein solches Paket 
							hat in der Regel eine kurze Lebensdauer und kann nicht
							wiederverwendet werden.
						</para>
						<para>
							Dieses Simulator Packet ist in keinster Weise mit einem 
							Modul Packet gleichzusetzen oder zu verwechseln. Informationen
							zum Interface eines Modul Packets 
							befinden sich im Abschnitt
							<xref linkend="design.module.packet" />.
						</para>
						<para>
							In Abschnitt 
							<xref linkend="implementation.module.packet" />
							wird auf die Details der Implementierung dieses
							Interface
							eingegangen.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
		<section>
			<title>Modul</title>
			<para>
				Ein Modul besteht aus einer Menge von Komponenten, welche
				vom Simulator ausgeführt werden. Die Komponenten übernehmen
				dabei selbst ihre Aufgabe und implementieren alle nötigen
				Funktionalitäten.
			</para>
		</section>
		<section>
			<title>Steps</title>
			<para>
				Ein <quote>Step</quote>, oder auch <quote>Schritt</quote>
				ist die kleinste Zeiteinheit im Simulator. Innerhalb einem
				Schritt werden alle Komponenten einmal ausgeführt.
			</para>
		</section>
	</section>
	<section>
		<title>Funktionsweise</title>
		<para>
			Der Simulator ist die ausführende Einheit eines Moduls.
			Dieser hat dabei folgende wesentlichen Aufgaben zu bewältigen:
			<itemizedlist>
				<listitem><para>Modul laden</para></listitem>
				<listitem><para>Objekte instanzieren</para></listitem>
				<listitem><para>Schrittweise simulieren</para></listitem>
			</itemizedlist>
		</para>
		<para>
			Nach jedem Simulationsschritt werden alle Veränderungen an
			den Objektinstanzen des geladenen Moduls an die Visualisierung
			weitergegeben. Die Informationen sind dem Simulator als
			<quote>Variablen</quote> bekannt. Der Simulator soll
			die Objektinstanzen eines Moduls überwachen und Änderungen
			am Status eines Objekts in diesen Variablen abspeichern.
			Variablen enthalten somit alle nötigen Informationen zum
			Status eines Objekts. Weiters soll es möglich sein in einem 
			Modul mittels Java Annotations zu entscheiden welche
			Instanzen beobachtet werden sollen.
		</para>
		<section>
			<title>Modul laden</title>
			<para>
				In diesem Kapitel wird die Funktionalität <quote>Modul laden</quote>
				definiert und beschrieben.
			</para>
			<para>
				Der Simulator implementiert die Funktion
				<methodsynopsis>
					<methodname>importSimFile</methodname>
					<methodparam>
						<type>IModuleFileComponent</type>
						<parameter>simFile</parameter>
					</methodparam>
				</methodsynopsis> implementieren um eine MSIM-Datei
				zu importieren.
			</para>
			<para>
				Das Interface 
				<classsynopsis>
					<oointerface>
						<package>vidis.sim.classloader.modules.interfaces</package>
						<modifier>public</modifier>
						<interfacename>IModuleFileComponent</interfacename>
					</oointerface>
				</classsynopsis>
				beschreibt eine MSIM-Datei und definiert folgende Funktionen:
				<itemizedlist>
					<listitem>
						<para>
							Diese Funktion öffnet einen InputStream zur MSIM-Datei
							welche diese Klasse repräsentiert.
						</para>
						<methodsynopsis>
							<modifier>public</modifier>
							<type>InputStream</type>
							<methodname>getInputStream</methodname>
							<void/>
							<exceptionname>IOException</exceptionname>
						</methodsynopsis>
					</listitem>
					<listitem>
						<para>
							Diese Funktion gibt den Namen dieser MSIM-Datei zurück.
							Dies kann der Dateiname, aber auch ein Bezeichner aus einer
							Meta-Information eines Jar-Archivs sein.
						</para>
						<methodsynopsis>
							<modifier>public</modifier>
							<type>String</type>
							<methodname>getName</methodname>
							<void/>
						</methodsynopsis>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Anschließend soll der Simulator versuchen, die Datei zu öffnen
				und den Inhalt mittels eines InputStream's einzulesen. Dieser
				InputStream soll dazu einem XML Parser übergeben werden, welcher
				die Datei analysiert und alle wichtigen Informationen extrahiert.
				Für XML	gibt es zwei Möglichkeiten eine Datei zu parsen:
				<itemizedlist>
					<listitem><para>DOM</para></listitem>
					<listitem><para>SAX</para></listitem>
				</itemizedlist>
			</para>
			<para>
				Ein DOM Parser liest das Dokument als Ganzes ein und 
				baut daraus einen DOM-Tree über welchen man auf die 
				Objekte zugreifen kann.
			</para>
			<para>
				Ein SAX Parser liest das Dokument über den Stream ein
				und reagiert auf das Öffnen und Schließen eines Tags.
			</para>
			<note>
				<para>
					Ein tiefgründigerer Vergleich der Technologien
					befindet sich hier:
					<xref linkend="compare_xml_sax_dom" />
				</para>
			</note>
			<para>
				Die MSIM-Dateien sind relativ kleine Dokumente, welche
				in sich auf Elemente verweisen. Auch die Struktur
				von MSIM-Dateien bleibt dabei immer die selbe. Aus diesen
				Gründen eignet
				sich ein DOM Parser besser für die Anwendung in VIDIS und
				wurde so implementiert.
			</para>
		</section>
	</section>
	<section>
		<title>Player</title>
		<para>
			Eng verbunden mit dem Simulator steht der Player.
			Der Player ist die kontrollierende Einheit für den 
			Simulator. Er kümmert sich darum, einen Simulationsschritt
			anzustossen. Somit ist er das kontrollierende
			Verbindungsstück zwischen Simulation und Visualisierung.
		</para>
		<para>
			Der Player hat mehrere Zustände. Im folgenden
			werden diese Zustände erläutert.
		</para>
		<itemizedlist>
			<listitem>
				<fieldsynopsis>
					<modifier>public</modifier>
					<type>boolean</type>
					<varname>paused</varname>
				</fieldsynopsis>
				<para>
					Ist der Simulator nicht gestoppt, kodiert dieser
					Zustand ob ein weiterer Simulationsschritt
					ausgeführt werden soll.
				</para>
			</listitem>
			<listitem>
				<fieldsynopsis>
					<modifier>public</modifier>
					<type>boolean</type>
					<varname>stopped</varname>
				</fieldsynopsis>
				<para>
					In diesem Zustand ist der Simulator gestoppt,
					das Modul neu geladen, die Objekte richtig
					instantiiert und der Simulator bereit zu starten.
				</para>
			</listitem>
			<listitem>
				<fieldsynopsis>
					<modifier>public</modifier>
					<type>boolean</type>
					<varname>killed</varname>
				</fieldsynopsis>
				<para>
					Kodiert den Zustand des korrekten Beendens
					des Simulators.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Folgendes Zustandübergangsdiagramm veranschaulicht die Zustandsmaschine
			Player.
		</para>
		<figure>
			<title>Zustandsübergangsdiagramm des Players</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="figures/zustandsübergangsdiagramm-player.png" width="400" align="center">
					</imagedata>
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			Er implementiert folgende Funktionalität:
			<itemizedlist>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>play</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion startet den Simulator falls
						er noch nicht gestartet wurde. Wurde der Simulator
						bereits gestartet, hat diese Funktion keinen Effekt.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>pause</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion pausiert den Simulator. Wurde der Simulator
						bereits pausiert, startet diese Funktion den Simulator.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>playPause</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion startet bzw stoppt den Simulator.
						Wurde der Simulator gestoppt, ruft diese Funktion
						play() auf. Wurde der Simulator hingegen nicht
						gestoppt, ruft diese Funktion pause() auf.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>stop</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion stoppt den Simulator. Ist der Simulator
						bereits gestoppt hat ein Aufruf dieser Funktion keine
						Auswirkung.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>kill</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion veranlasst den Simulator dazu,
						alle allokierten Ressourcen freizugeben und
						erlaubt dem Player-Thread zu sterben.
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>Datenstruktur (intern)</title>
		<para>
			Ein wesentlicher Teil des Designs des Simulators war
			die Datenstruktur, in welcher sowohl die zu simulierenden
			Komponenten, als auch der Zustand des Simulators abgespeichert
			werden muss. Im folgenden wird diese Datenstruktur zunächst
			formal und anschließend mittels Methodenrümpfe beschrieben.
		</para>
		<para>
			<phrase>Die Datenstruktur des Simulators ist ein Tupel
			(M, t), wobei M die Menge der ausführbaren Komponenten ist
			und t der aktuelle Simulationsschritt ist.</phrase>
		</para>
		<para>
			Diese Datenstruktur ist in der Klasse SimulatorData implementiert.
			Die Klasse enthält die Felder:
			<itemizedlist>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>long</type>
						<varname>now</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>List&lt;AComponent&gt;</type>
						<varname>components</varname>
					</fieldsynopsis>
				</listitem>
			</itemizedlist>
			Die Klasse enthält im Wesentlichen diese Funktionen:
			<itemizedlist>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>long</type>
						<methodname>getTime</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion gibt den aktuellen Simulationsschritt
						zurück.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>registerComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
					<para>
						Diese Funktion registriert eine Komponente in der internen
						Datenstruktur. Nach Aufruf dieser Funktion wird 
						die Komponente vom Simulator simuliert. 
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>unregisterComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
					<para>
						Diese Funktion löscht eine Komponente aus der
						internen Datenstruktur. Nach Aufruf dieser Funktion
						wird diese Komponente nicht mehr vom Simulator
						simuliert.
					</para>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>executeComponents</methodname>
						<void/>
					</methodsynopsis>
					<para>
						Diese Funktion ruft auf allen registrierten Komponenten
						die Funktion <methodsynopsis>
							<modifier>public</modifier>
							<type>void</type>
							<methodname>execute</methodname>
							<void/>
						</methodsynopsis> auf. Dies wird vom Simulator
						zu jedem Simulationsschritt ausgeführt.
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</section>
</section>