<?xml version="1.0" encoding="UTF-8"?>
<section
	xmlns="http://docbook.org/ns/docbook">
	<title>Simulator</title>
	<section>
		<title>Funktionsweise</title>
		<para>
			Der Simulator ist die ausführende Einheit eines Moduls.
			Dieser hat folgende wesentlichen Aufgaben:
			<itemizedlist>
				<listitem><para>Modul laden</para></listitem>
				<listitem><para>Objekte instantiieren</para></listitem>
				<listitem><para>Schrittweise simulieren</para></listitem>
			</itemizedlist>
		</para>
		<para>
			Nach jedem Simulationsschritt werden alle Veränderungen an
			den Objektinstanzen des geladenen Moduls auf der Benutzeroberfläche
			dargestellt.
		</para>
		<section>
			<title>Modul laden</title>
			<para>
				In diesem Kapitel wird die Funktionalität <quote>Modul laden</quote>
				definiert.
			</para>
			<para>
				Der Simulator soll die Funktion
				<methodsynopsis>
					<methodname>importSimFile</methodname>
					<methodparam>
						<type>IModuleFileComponent</type>
						<parameter>simFile</parameter>
					</methodparam>
				</methodsynopsis> implementieren um eine MSIM-Datei
				zu importieren.
			</para>
			<para>
				Das Interface 
				<classsynopsis>
					<oointerface>
						<package>vidis.sim.classloader.modules.interfaces</package>
						<modifier>public</modifier>
						<interfacename>IModuleFileComponent</interfacename>
					</oointerface>
				</classsynopsis>
				beschreibt eine MSIM-Datei und definiert folgende Funktionen:
				<itemizedlist>
					<listitem>
						<para>
							Diese Funktion öffnet einen InputStream zur MSIM-Datei
							welche diese Klasse repräsentiert.
						</para>
						<methodsynopsis>
							<modifier>public</modifier>
							<type>InputStream</type>
							<methodname>getInputStream</methodname>
							<void/>
							<exceptionname>IOException</exceptionname>
						</methodsynopsis>
					</listitem>
					<listitem>
						<para>
							Diese Funktion gibt den Namen dieser MSIM-Datei zurück.
							Dies kann der Dateiname, aber auch ein Bezeichner aus einer
							Meta-Information eines Jar-Archivs sein.
						</para>
						<methodsynopsis>
							<modifier>public</modifier>
							<type>String</type>
							<methodname>getName</methodname>
							<void/>
						</methodsynopsis>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Anschließend soll der Simulator versuchen, die Datei zu öffnen
				und den Inhalt mittels eines InputStream's einzulesen. Dieser
				InputStream soll dazu einem XML Parser übergeben werden, welcher
				die Datei analysiert und alle wichtigen Informationen extrahiert.
				Für XML	gibt es zwei Möglichkeiten eine Datei zu parsen:
				<itemizedlist>
					<listitem><para>DOM</para></listitem>
					<listitem><para>SAX</para></listitem>
				</itemizedlist>
			</para>
			<para>
				Ein DOM Parser liest das Dokument als Ganzes ein und 
				baut daraus einen DOM-Tree über welchen man auf die 
				Objekte zugreifen kann.
			</para>
			<para>
				Ein SAX Parser liest das Dokument über den Stream ein
				und reagiert auf das Öffnen und Schließen eines Tags.
			</para>
			<note>
				<para>
					Ein Vergleich der Technologien befindet sich hier:
					<xref linkend="compare_xml_sax_dom" />
				</para>
			</note>
			<para>
				Da die Vorteile eines DOM Parsers für unsere Anwendung
				überwiegen, haben wir uns dafür entschieden diesen zu
				verwenden.
			</para>
		</section>
	</section>
	<section>
		<title>Player</title>
		<para>Der Player ist die kontrollierende Einheit für den 
		Simulator. Er kümmert sich darum, einen Simulationsschritt
		anzustossen. Somit ist er das Verbindungsstück zwischen 
		Simulation und Visualisierung.</para>
		<para>
			Der Player hat mehrere Zustände.
			<itemizedlist>
				<listitem>
					<para>
						Ist der Simulator nicht gestoppt, kodiert dieser
						Zustand ob ein weiterer Simulationsschritt
						ausgeführt werden soll.
					</para>
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>paused</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
					<para>
						In diesem Zustand ist der Simulator gestoppt,
						das Modul neu geladen, die Objekte richtig
						instantiiert und der Simulator bereit zu starten.
					</para>
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>stopped</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
					<para>
						Kodiert den Zustand des korrekten Beendens
						des Simulators.
					</para>
					<fieldsynopsis>
						<modifier>public</modifier>
						<type>boolean</type>
						<varname>killed</varname>
					</fieldsynopsis>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			Folgendes Zustandübergangsdiagramm veranschaulicht die Zustandsmaschine
			Player.
		</para>
		<figure>
			<title>Zustandsübergangsdiagramm des Players</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="figures/zustandsübergangsdiagramm-player.png" width="400" align="center">
					</imagedata>
				</imageobject>
			</mediaobject>
		</figure>
		<para>
			Er implementiert folgende Funktionalität:
			<itemizedlist>
				<listitem>
					<para>
						Diese Funktion startet den Simulator falls
						er noch nicht gestartet wurde. Wurde der Simulator
						bereits gestartet, hat diese Funktion keinen Effekt.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>play</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<para>
						Diese Funktion pausiert den Simulator. Wurde der Simulator
						bereits pausiert, startet diese Funktion den Simulator.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>pause</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<para>
						Diese Funktion startet bzw stoppt den Simulator.
						Wurde der Simulator gestoppt, ruft diese Funktion
						play() auf. Wurde der Simulator hingegen nicht
						gestoppt, ruft diese Funktion pause() auf.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>playPause</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<para>
						Diese Funktion stoppt den Simulator. Ist der Simulator
						bereits gestoppt hat ein Aufruf dieser Funktion keine
						Auswirkung.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>stop</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<para>
						Diese Funktion veranlasst den Simulator dazu,
						alle allokierten Ressourcen freizugeben und
						erlaubt dem Player-Thread zu sterben.
					</para>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>kill</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>Datenstruktur (intern)</title>
		<para>
			<phrase>Die Datenstruktur des Simulators ist ein Tupel
			(M, t), wobei M die Menge der ausführbaren Komponenten ist
			und t der aktuelle Simulationsschritt ist.</phrase>
		</para>
		<para>
			Diese Datenstruktur ist in der Klasse SimulatorData implementiert.
			Die Klasse enthält die Felder:
			<itemizedlist>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>long</type>
						<varname>now</varname>
					</fieldsynopsis>
				</listitem>
				<listitem>
					<fieldsynopsis>
						<modifier>private</modifier>
						<type>List&lt;AComponent&gt;</type>
						<varname>components</varname>
					</fieldsynopsis>
				</listitem>
			</itemizedlist>
			Die Klasse enthält im Wesentlichen diese Funktionen:
			<itemizedlist>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>long</type>
						<methodname>getTime</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>registerComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>unregisterComponent</methodname>
						<methodparam>
							<type>AComponent</type>
							<parameter>component</parameter>
						</methodparam>
					</methodsynopsis>
				</listitem>
				<listitem>
					<methodsynopsis>
						<modifier>public</modifier>
						<type>void</type>
						<methodname>executeComponents</methodname>
						<void/>
					</methodsynopsis>
				</listitem>
			</itemizedlist>
		</para>
	</section>
</section>