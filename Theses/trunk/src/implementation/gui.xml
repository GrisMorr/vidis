<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" 
	xmlns="http://docbook.org/ns/docbook"
	xml:id="section_gui">
	<title>Grafische Benutzeroberfläche</title>
	<para>Um dem Benutzer die Möglichkeit zu geben, mit der Simulation zu interagieren, wurde eine grafische Benutzeroberfläche entworfen und umgesetzt. Diese wird in den folgenden Kapiteln kurz vorgestellt und erklärt.</para>

	<section>
		<title>GUI Elemente</title>
		<para>
			Im folgenden wird auf die sichtbaren Benutzeroberflächen-Elemente näher eingegangen. Diese sind die 3D Szene, das in der linken unteren Ecke
			positionierte Menu und das auf der rechten Seite positionierte Eigenschaftenpanel. Die 2D Gui Elemente werden in diesem Abschnitt beschrieben.
			Nähere Informationen zur 3D Szene sind im Abschnitt <xref linkend="section_3dscene" /> zu finden.
		</para>
		
		<section>
			<title>Menu</title>
			<para>Am unteren linken Rand des Bildschirms befindet sich das Menu. Mit diesem kann der Benutzer Einfluss auf die Simulation ausüben.</para>
			<para>
				Das Menu ist durch ein Composite Pattern realisiert. 
				Jede Node fasst ein Steuerelement, eine Liste der Kinderelemente und das Vaterelement. 
				Zudem verfügt sie noch über die Information ob die Kinderelemente dargestellt, oder ausgeblendet werden sollen. 
				Wird eine Node aufgeklappt, rutschen alle Geschwisterelemente nach oben und dazwischen werden ihre Kinder gerendert. 

			</para>
			<para>
				Auf der Hauptebene dieser Struktur befinden sich 3 dauerhaft sichtbare Elemente:
				Im folgenden werden diese Element (von unten nach oben) erklärt:
			</para>
		<variablelist>
		<varlistentry>
			<term>Die Player Kontrollen</term>
			<listitem>
			<para>
				Die Player Kontrollen befinden sich ganz unten am Bildschirmrand. 
				Sie sind immer sichtbar und werden nicht durch das Menu verschoben. 
				Sie bestehen aus den 3 Buttons Play, Pause und Reset (vgl. <xref linkend="fig_playbuttons" />).
				Diese werden dazu verwendet, die Simulation zu starten, zu pausieren oder zum Startzustand zurückzusetzen.
			</para>
			<figure xml:id="fig_playbuttons">
				<title>Bildschirmfoto von den Playerkontrollen</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_playercontrol.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>Das Systemmenu</term>
			<listitem>
			<para>
				Im Systemmenu können Module geladen und Einstellungen vorgenommen werden (vgl. <xref linkend="fig_sysmenu" />).
			</para>
			<figure xml:id="fig_sysmenu">
				<title>Bildschirmfoto vom Systemmenu</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_sysmenu.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			<variablelist>
				<varlistentry>
					<term>Optionen</term>
					<listitem>
					<para>
						Hier kann unter anderem in den Wireframe Modus gewechselt werden. Im Wireframe Modus werden die Polygone nicht
						mehr ausgefüllt, sondern nur deren Kanten gezeichnet. 
					</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Layout</term>
					<listitem>
					<para>
						In diesem Untermenu kann man zwischen den vordefinierten Layouts wählen. Zur Auswahl stehen ein Random Layout, welches
						die Nodes zufällig platziert, ein Spiral Layout, welches die Nodes spiralförmig platziert, ein Grid Layout, welches die
						Nodes auf einem Raster anordnet und ein Electric Spring Layout, welches durch Gewichtung der Links den Abstand zwischen den
						Nodes solange verändert bis ein Gleichgewicht herrscht <!-- FIXME link to section_layouts if there is one -->.
					</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Laden</term>
					<listitem>
					<para>
						Dieses Untermenu stellt alle verfügbaren Module dar. Ein Modul ist verfügbar, wenn es im DropIn Folder abgelegt wurde. Für nähere Informationen
						zum DropIn Folder siehe <xref linkend="implementation.modules.dropinfolder" />.
					</para>
					</listitem>
				</varlistentry>
			</variablelist>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>Das Aktionsmenu</term>
			<listitem>
			<figure xml:id="fig_aktionsmenu">
				<title>Bildschirmfoto vom Aktionsmenu</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_aktionmenu.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			<para>
				Für die aktuell selektierte Node werden hier Aktionen zur Verfügung gestellt. Dies äußert sich durch einen Button pro möglicher Aktion.
				Voraussetzung dafür ist das der Modul-Entwickler in der Node Implementation Methoden vom Typ <type>void</type> mit @Display annotiert hat (vgl. <xref linkend="example_useraction" />).
			</para>
			<example xml:id="example_useraction">
				<title>Auszug aus einer Modul-Node-Implementation</title>
				<programlisting linenumbering="numbered"><![CDATA[@Display( name="Erzeuge Event" )
public void erzeugeEvent() {
	createSomeEvent();
}

@Display( name="Autom.Events" ) 
public void toggleAutoEvents {
	autoEvents = !autoEvents;
}]]></programlisting>
			</example>
			<para>Es wird zwischen 2 Arten von Methoden unterschieden:</para>
			<itemizedlist>
				<listitem>
					<para>Methoden ohne Parameter</para>
					<para>Methoden ohne Parameter werden durch einen einfachen Button dargestellt. Klickt man darauf wird direkt die vom Modul-Entwickler implementierte Methode ausgeführt.</para>
				</listitem>
				<listitem>
					<para>Methoden mit Parameter</para>
					<para>Diese Methode kann ohne vorherige Eingabe der Parameter nicht ausgeführt werden. Darum werden durch einen Klick auf diesen Button Felder für alle benötigten Parametern, sowie eine "ausführen" Button dargestellt.</para>
				</listitem>
			</itemizedlist>
			</listitem>
		</varlistentry>
		</variablelist>

		</section>

		<section>
			<title>Informations Panel</title>
			<para>Das Informationspanel befindet sich auf der rechten Seite. Es zeigt den aktuellen Status von den ausgewählten Objekten an. Für jede Methode (mit Rückgabewert), die vom Modul-Entwickler mit @Display annotiert wurde, ist hier eine Zeile mit Namen und Wert zu sehen.</para>
			<figure xml:id="figure_infopanel">
				<title>Das Informationspanel</title>
				<mediaobject>
					<imageobject>
						<imagedata />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Wie in <xref linkend="figure_infopanel" /> zu sehen ist, stellt das Informationspanel für jedes ausgeählte Objekt einen Container dar. Dieser Container kann 4 verschiedene Zustände annehmen:
			</para>
			<variablelist>
				<varlistentry>
				<term>minimized</term>
				<listitem>
					<para>
						Im minimized Zustand nimmt ein Container den minimalen Platz ein. Er besteht nur aus einer Zeile, welche die variable <literal>user.header1</literal> darstellt.
					</para>
				</listitem>
				</varlistentry><varlistentry>
				<term>normal</term>
				<listitem>
					<para>
						Im normal Zustand ist der Container 2 Zeilen hoch. Es werden die Variablen <literal>user.header1</literal> und <literal>user.header2</literal> dargestellt.
					</para>
				</listitem>
				</varlistentry><varlistentry>
				<term>maximized</term>
				<listitem>
					<para>
						Der Container im maximized Zustand besteht aus 2 Teilen. Zum einen den Kopf, welcher exakt wie der normal Container aussieht und zum Anderen den Körper, welcher eine
						scrollbare Liste von allen Variablen und deren Werten beinhaltet. Dies sind außerdem noch in Namespaces zusammengefasst um die Naviagtion zu erleichtern.
					</para>
				</listitem>
				</varlistentry><varlistentry>
				<term>maximized2</term>
				<listitem>
					<para>
						Der maximized2 Zustand basiert auf dem maximized Zustand und vergrößert dabei den Körper, um mehr Variablen auf einmal sehen zu können.
					</para>
				</listitem>
				</varlistentry>
			</variablelist>
			<para>
				Die Zustände maximized und maximized2 zeigen die Variablen an. Diese werden in der Form <literal>NAME: VALUE</literal> dargestellt. Dabei wird für <literal>VALUE</literal> je nach 
				Typ eine andere Klasse zum rendern verwendet. Beispielsweise werden Vektoren in der Form <literal>( 5.00, 1.23, -0.23 )</literal> angezeigt. Der Default-Renderer interpretiert
				<literal>VALUE</literal> als String. Dazu wird die toString() Methode verwendet. 
			</para>
			<para>
				In einer Map werden die Beziehungen Klasse auf Renderer abgebildet. Wird eine Variable registriert entscheidet die GUI anhand dieser Map welcher Renderer eingesetzt wird. Ist kein 
				Eintrag für den Datentyp vorhanden, wird der Default-Renderer eingesetzt.
			</para>
		</section>
		<para></para>
		<para>
			In diesem Abschnitt wurden die GUI Elemente beschrieben. Als nächstes wird die Benztzerinteraktion mit Maus und Tastatur erklärt.
		</para>

	</section>

	<section>
		<title>Benutzer Interaktion</title>
		<para>
			Damit der Benutzer das Vidis System bedienen kann, müssen Maus und Tastaturevents ausgewertet werden. Im folgenden wird erklärt, wie das System bedient werden kann, und es wird auf 
			die dahinter stehende Implementierung eingegangen.
		</para>

		<variablelist>
			<varlistentry>
				<term>Maus Interaktion</term>
				<listitem>
					<para>
						Mit einfachen Mausklicks können alle Steuerelemente in der Benutzeroberflächer bedient werden und die 3-dimensionalen Nodes sind auswählbar (siehe 
						<xref linkend="section_picking" />).
					</para>
					<para>
						Bei gedrückter rechter Maustaste wird ein aus Spielen bekannter <quote>Free Look</quote> Modus aktiviert. Dabei kann man durch Bewegen der Maus
						in jede beliebige Richtung schauen.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Tastatur Interaktion</term>
				<listitem>
					<para>
						Mit den Tasten W, A, S und D lässt sich die Kamera bewegen. Dabei bewegt sich mit A und S die Kamera in Blickrichtung vor bzw zurück und mit
						A und D seitwärts nach links oder rechts.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Das Kernstück der Maus und Tastaturimplementierung ist der Inputcontroller. Er bekommt jedes Maus und Tastaturevent und entscheidet, wie es verarbeitet wird.
		</para>
		<para>
			Mausevents werden zunächst an den GUI Controller weitergeleitet. Dieser berechnet die Mauskoordinaten für die GUI und reicht das Event an den äußersten GuiContainer
			weiter. Dieser reicht das Event an den betroffenen Subcontainer weiter. Existiert kein Subcontainer unter der Maus, dann war der Klick für die 3D Welt bestimmt.  Das 
			Event wieder zurück in das Event System geworfen und landet beim Scenecontroller. Dieser berechnet nun mittels Picking (siehe <xref linkend="section_picking" />) 
			welche 3D Objekte angeklickt wurden. Schlussendlich bekommt entweder ein GUI Element, oder ein 3D Objekt das Klick Event.
		</para>
		<para>
			Tastaturevents werden direkt vom Imputkontoller über eine Mapping Tabelle zu VidisEvents umgewandelt. Das heisst wird zum Beispiel 'A' gedrückt, so wirft der Inputkontroller
			ein Event, dass die Kamera sich ab jetzt nach links bewegen soll. Wird 'A' wieder losgelassen so wird ein Event geworfen, welches die Kamera anweist, sich jetzt nicht mehr
			nach Links zu bewegen.
		</para>
	</section>
	<para></para>
	<para>Damit wäre die grafische Benutzeroberfläche erklärt. Auf den folgenden Seiten werden Module vorgestellt, und es wird auf deren Implemntierung näher eingegangen.</para>
</section>
