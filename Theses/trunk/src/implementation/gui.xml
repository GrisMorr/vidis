<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" 
	xmlns="http://docbook.org/ns/docbook">
	<title>Grafische Benutzeroberfläche</title>
	<para>Um dem Benutzer die Möglichkeit zu geben, mit der Simulation zu interagieren, wurde eine grafische Benutzeroberfläche entworfen und umgesetzt. Diese wird in den folgenden Kapiteln kurz vorgestellt und erklärt.</para>

	<section>
		<title>GUI Elemente</title>
		<para>
			Im folgenden wird auf die sichtbaren Benutzeroberflächen-Elemente näher eingegangen. Diese sind im Grunde das in der linken unteren Ecke
			positionierte Menu und das auf der rechten Seite positionierte Eigenschaftenpanel.
		</para>
		
		<section>
			<title>Menu</title>
			<para>Am unteren linken Rand des Bildschirms befindet sich das Menu. Mit diesem kann der Benutzer Einfluss auf die Simulation ausüben.</para>
			<para>
				Das Menu ist durch ein Composite Pattern realisiert. 
				Jede Node fasst ein Steuerelement, eine Liste der Kinderelemente und das Vaterelement. 
				Zudem verfügt sie noch über die Information ob die Kinderelemente dargestellt, oder ausgeblendet werden sollen. 
				Wird eine Node aufgeklappt, rutschen alle Geschwisterelemente nach oben und dazwischen werden ihre Kinder gerendert. 

			</para>
			<para>
				Auf der Hauptebene dieser Struktur befinden sich 3 dauerhaft sichtbare Elemente:
				Im folgenden werden diese Element (von unten nach oben) erklärt:
			</para>
		<variablelist>
		<varlistentry>
			<term>Die Player Kontrollen</term>
			<listitem>
			<para>
				Die Player Kontrollen befinden sich ganz unten am Bildschirmrand. 
				Sie sind immer sichtbar und werden nicht durch das Menu verschoben. 
				Sie bestehen aus den 3 Buttons Play, Pause und Reset (vgl. <xref linkend="fig_playbuttons" />).
			</para>
			<figure xml:id="fig_playbuttons">
				<title>Bildschirmfoto von den Playerkontrollen</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_playercontrol.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>Das Systemmenu</term>
			<listitem>
			<para>
				Im Systemmenu können Module geladen und Einstellungen vorgenommen werden (vgl. <xref linkend="fig_sysmenu" />).
			</para>
			<figure xml:id="fig_sysmenu">
				<title>Bildschirmfoto vom Systemmenu</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_sysmenu.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			<itemizedlist>
				<listitem>
					<para>Optionen</para>
					<para>Hier kann unter anderem in den Wireframe Modus gewechselt werden.</para>
				</listitem>
				<listitem>
					<para>Layout</para>
					<para>In diesem Untermenu kann man zwischen den vordefinierten Layouts wählen.</para>
				</listitem>
				<listitem>
					<para>Laden</para>
					<para>Dieses Untermenu stellt alle verfügbaren Module dar.</para>
				</listitem>
			</itemizedlist>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>Das Aktionsmenu</term>
			<listitem>
			<figure xml:id="fig_aktionsmenu">
				<title>Bildschirmfoto vom Aktionsmenu</title>
				<screenshot>
					<mediaobject>
						<imageobject>
							<imagedata align="center" width="150" format="PNG" fileref="image/screenshot_aktionmenu.png" />
						</imageobject>
					</mediaobject>	
				</screenshot>
			</figure>
			<para>
				Für die aktuell selektierte Node werden hier Aktionen zur Verfügung gestellt. Dies äußert sich durch einen Button pro möglicher Aktion.
				Voraussetzung dafür ist das der Modul-Entwickler in der Node Implementation Methoden vom Typ <type>void</type> mit @Display annotiert hat (vgl. <xref linkend="example_useraction" />).
			</para>
			<example xml:id="example_useraction">
				<title>Auszug aus einer Modul-Node-Implementation</title>
				<programlisting linenumbering="numbered">
@Display( name="Erzeuge Event" )
public void erzeugeEvent() {
	createSomeEvent();
}

@Display( name="Autom.Events" ) 
public void toggleAutoEvents {
	autoEvents = !autoEvents;
}
				</programlisting>
			</example>
			<para>Es wird zwischen 2 Arten von Methoden unterschieden:</para>
			<itemizedlist>
				<listitem>
					<para>Methoden ohne Parameter</para>
					<para>Methoden ohne Parameter werden durch einen einfachen Button dargestellt. Klickt man darauf wird direkt die vom Modul-Entwickler implementierte Methode ausgeführt.</para>
				</listitem>
				<listitem>
					<para>Methoden mit Parameter</para>
					<para>Diese Methode kann ohne vorherige Eingabe der Parameter nicht ausgeführt werden. Darum werden durch einen Klick auf diesen Button Felder für alle benötigten Parametern, sowie eine "ausführen" Button dargestellt.</para>
				</listitem>
			</itemizedlist>
			</listitem>
		</varlistentry>
		</variablelist>

		</section>

		<section>
			<title>Informations Panel</title>
			<para>Das Informationspanel befindet sich auf der rechten Seite. Es zeigt den aktuellen Status von den ausgewählten Objekten an. Für jede Methode (mit Rückgabewert), die vom Modul-Entwickler mit @Display annotiert wurde, ist hier eine Zeile mit Namen und Wert zu sehen.</para>
		</section>

	</section>

	<section>
		<title>Benutzer Interaktion</title>
		<para>
			Damit der Benutzer das Vidis System bedienen kann, müssen Maus und Tastaturevents ausgewertet werden. Im folgenden wird erklärt, wie das System bedient werden kann, und es wird auf 
			die dahinter stehende Implementierung eingegangen.
		</para>

		<variablelist>
			<varlistentry>
				<term>Maus Interaktion</term>
				<listitem>
					<para>
						Mit einfachen Mausklicks können alle Steuerelemente in der Benutzeroberflächer bedient werden und die 3 dimensionalen Nodes sind auswählbar (siehe 
						<xref linkend="section_picking" />).
					</para>
					<para>
						Bei gedrückter rechter Maustaste wird ein aus Spielen bekannter <quote>Free Look</quote> Modus aktiviert. Dabei kann man durch Bewegen der Maus
						in jede beliebige Richtung schauen.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Tastatur Interaktion</term>
				<listitem>
					<para>
						Mit den Tasten W, A, S und D lässt sich die Kamera bewegen. Dabei bewegt sich mit A und S die Kamera in Blickrichtung vor bzw zurück und mit
						A und D seitwärts nach links oder rechts.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Das Kernstück der Maus und Tastaturimplementierung ist der Inputcontroller. Er bekommt jedes Maus und Tastaturevent und entscheidet, wie es verarbeitet wird.
		</para>
		<para>
			Mausevents werden zunächst an den GUI Controller weitergeleitet. Dieser berechnet die Mauskoordinaten für die GUI und reicht den Event and den äußersten GuiContainer
			weiter. Dieser reicht den Event an den betroffenen Subcontainer weiter. Existiert kein Subcontainer unter der Maus, dann war der Klick für die 3D Welt bestimmt.  Der 
			Event wieder zurück in das Event System geworfen und landet beim Scenecontroller. Dieser berechnet nun mittels Picking (siehe <xref linkend="section_picking" />) 
			welche 3D Objekte angeklickt wurden. Schlussendlich bekommt entweder ein GUI Element, oder ein 3D Objekt das Klick Event.
		</para>
		<para>
			Tastaturevents werden direkt vom Imputkontoller über eine Mapping Tabelle zu VidisEvents umgewandelt. Das heisst wird zum Beispiel 'A' gedrückt, so wirft der Inputkontroller
			ein Event, dass die Kamera sich ab jetzt nach links bewegen soll. Wird 'A' wieder losgelassen so wird ein Event geworfen, welches die Kamera anweist, sich jetzt nicht mehr
			nach Links zu bewegen.
		</para>
	</section>

</section>
