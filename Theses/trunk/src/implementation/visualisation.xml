<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Visualisierung</title>
	<para>
		Im folgenden wird auf die Implementierung der Visualisierung eingegangen. Es werden insbesondere aufgetretene Probleme, sowie deren Lösungsansätze beschrieben.
	</para>	
	<?dbfo keep-with-next="auto" ?>	
	 
	<section xml:id="section_3dscene">
		<title>3D Szene</title>
		<para>
			Um 3D Content am Computerbildschirm darzustellen wurde <trademark class="registered">OpenGL</trademark> verwendet. 
			Wie bereits im Kapitel <xref linkend="section_opengl_bindings" /> erklärt, wurde JOGL als Java-Binding gewählt.
		</para>	
		<para>
			Die 3D Szene wird vom <literal>Scenecontroller</literal> verkörpert. Dieser führt auch den Rendervorgang durch.
			Über das Eventsystem werden bei ihm die zu rendernden Objekte registriert oder, wenn sie nicht mehr benötigt werden, wieder gelöscht. 
			In jedem Renderdurchgang iteriert der <literal>Scenecontroller</literal> über alle Objekte und ruft deren
			<literal>render()</literal> Methoden auf. Diese enthalten die <trademark class="registered">OpenGL</trademark> Befehle, die nötig sind um das Objekt zu zeichnen und an die richtige 
			Position zu bewegen.
		</para>
	</section>

	<section>
		<title>Die Objektpositionierung</title>
		<para>
			Die Positionen der Objekte werden im Variablensystem abgelegt. Nähere Informationen rund um das Variablensystem sind im Kapitel <xref linkend="section_variablensystem" /> zu finden. 
			Jedes positionierbare Objekt hat die Variable <literal>system.position</literal> vom
			Typ <literal>Point3d</literal>. Die abstrakte Objektimplementiering verwendet diese Information um eine Translation durchzuführen, bevor die konkrete Implementierung das
			Objekt zeichnet. Komplexere Objekte, wie der Link, überschreiben diese abstrakte Implementierung, da ihre Position und Form von den verbundenen
			Nodes abhängt und nicht durch einen Punkt definiert werden kann.
		</para>
	</section>

	<section>
		<title>Displaylisten</title>
		<para>
			Displaylisten ermöglichen es viele <trademark class="registered">OpenGL</trademark> Befehle zusammenzufassen und im Grafikspeicher abzulegen. Eine solche Liste kann dann später
			mit nur einem Befehl ausgeführt werden. Displaylisten bringen extra Performance, da oft verwendete Befehle nicht extra an den Grafikprozessor (GPU) geschickt werden müssen.
			VIDIS bedient sich dieser Technik und erzeugt beim ersten Rendervorgang eines Objekts eine Displayliste, welche dann in jedem weiteren Rendervorgang aufgerufen wird.
			Dadurch werden nur beim Generieren der Displaylisten Hautpprozessor (CPU) und GPU belastet und bei jedem weiteren Aufruf ausschlißlich die GPU.
		</para>
		<para>
			Verändert sich ein Objekt, so muss eine neue Displayliste generiert werden. Beispielsweise löst eine Objektpositionierung oder eine Änderung der Objektfarbe eine Neuberechnung 
			der Displayliste aus.
		</para>
	</section>
	
	<section xml:id="section_picking">
		<title>Picking</title>
		<para>
			Unter Picking versteht man den Prozess, herauszufinden auf welches 3D Objekt ein Benutzer geklickt hat. Man unterscheidet zwischen 
			verschiedenen Varianten wie ein solcher Agorithmus arbeitet:
		</para>
		<section>
			<title>Ray Picking</title>
			<para>
				Beim Ray Picking werden die 2D Koordinaten des Klicks zu einer Geraden im 3D Raum umgerechnet (vgl. 
				<xref linkend="fig_raypicking" /> ray).	Dieser <quote>Strahl</quote> schneidet alle Objekte, die sich unter der Maus befinden.
			</para>
			<figure xml:id="fig_raypicking">
				<title>Ray Picking</title>
				<mediaobject>
					<imageobject>
						<imagedata align="center" width="80%" fileref="image/raypicking.svg" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Dazu benötigt man zuerst die Transformationsmatrizen, durch die das 2 dimensionale Bild zu Stande kommt. Diese lassen sich mit
				dem entsprechenden <trademark class="registered">OpenGL</trademark> Kommando auslesen. Aus den Inversen dieser Matrizen und den
				Mauskoordinaten kann man die Gerade, die alle Objekte unter der Maus schneidet berechnen. Die GLU Bibliothek bietet dazu 
				eine Hilfsroutine, welche genau diese Berechnung durchführt. 
					<methodsynopsis language="java">
						<modifier>public</modifier>
						<type>boolean</type>
						<methodname>gluUnProject</methodname>
						<methodparam><type>double</type><parameter>winX</parameter></methodparam>
						<methodparam><type>double</type><parameter>winY</parameter></methodparam>
						<methodparam><type>double</type><parameter>winZ</parameter></methodparam>
						<methodparam><type>DoubleBuffer</type><parameter>model</parameter></methodparam>
						<methodparam><type>DoubleBuffer</type><parameter>proj</parameter></methodparam>
						<methodparam><type>IntBuffer</type><parameter>view</parameter></methodparam>
						<methodparam><type>DoubleBuffer</type><parameter>objPos</parameter></methodparam>
					</methodsynopsis>
				Der Programmier muss zum Zeitpunkt des Mausklicks die entsprechenden Matrizen auslesen, zwei mal gluUnProject aufrufen (einmal für den
				Punkt auf der Near-Plane und ein zweites mal für den Punkt auf der Far-Plane) und kann dann die durch diese beiden Punkte definierte
				Gerade mit den 3D Objekten schneiden.
			</para>
		</section>
		<section>
			<title>Farb Picking mit Back Buffer</title>
			<para>
				Die Idee hinter dieser Technik ist es, sich die Renderingpipeline der Grafikhardware zunutze zu machen. 
				Jedes klickbare Objekt wird mit einer eindeutigen Id, in Form einer Farbe, versehen. 
				Erfolgt nun ein Klick, wird in einen kleinen Viewport, der die Mausposition als Zentrum hat, die Szene gerendert.
				Der Farbwert unter der Maus identifiziert angeklickte Objekt eindeutig.
			</para>
		</section>
		<section>
			<title>Picking mit Id Stack</title>
			<para>
				Auch dieser Ansatz macht sich die Renderingpipeline zunutze.
				Ähnlich wie bei der zuvor vorgestllten Methode werden für alle klickbaren Objekte IDs vergeben. 
				Allerdings werden diese nicht durch die Farbe codiert, sondern mit dafür vogesehenen Befehlen zusätzlich gesetzt.
			</para>
		</section>
		<para>
		</para>
		<para>
			Vidis verwendet das oben vorgestellte Ray Picking, da sich dieses System gut mit dem Eventsystem integriert und keinen zusätzlichen Rederdurchgang benötigt.
			Für nähere Informationen und Implementierungsbeispiele aller drei Methoden wird auf das Redbook verwiesen <xref linkend="book_redbook" />. 
		</para>
	</section>	
	<section xml:id="section_links">
		<title>Gebogene Links</title>
		<para>
			Links zwischen Nodes werden als gewölbte Rohre dargestellt (vgl. <xref linkend="fig_linkexample" />). 
			Da die Positionen der Nodes variabel sind kann kein fixes 3D Modell für den Link verwendet werden. 
			Bei der Erstpositionierung und jeder weiteren Neupositionierung einer Node müssen immer alle damit verbundenen Links neu berechnet werden.
		</para>
		<figure xml:id="fig_linkexample">
			<title>Ein Link aus der finalen Programmversion</title>
			<screenshot>
				<mediaobject>
					<imageobject>
						<imagedata align="center" width="100%" type="PNG" fileref="image/screenshot_link.png" />
					</imageobject>
				</mediaobject>
			</screenshot>
		</figure>
		<para>
			Dieses "gebogene Rohr" folgt einer quadratischen Bézierkurve und wurde durch 4 Bézier Flächen dargestellt. 
			<trademark class="registered">OpenGL</trademark> bietet Evaluatoren an, um Bézier Berechnungen durchzufüheren. 
			Es werden nur die Kontrollpunkte und die Anzahl der gewünschten interpolierten Punkte angegeben und die <trademark class="registered">OpenGL</trademark> Evaluatoren interpolieren
			die zusätzlichen Punkte, bevor die restlichen Operationen auf die Vertexdaten angewendet werden. <xref linkend="fig_renderpipeline" /> zeigt an welcher Steller der Renderingpipeline
			die Evaluatoren ausgeführt werden.
		</para>
		<para>
			Im Zuge dieser Bakkarbeit wurde für den Java3D Prototypen der DeCasteljau Subdivision Algorithmus implementiert, da Java3D die OpenGL Evaluatoren nicht unterstützt. 
			Für die JOGL Version wurden die OpenGL Evaluatoren verwendet.</para>
	</section>
	<section>
		<title>Linkwölbung für Pakete</title>
		<para>Ein Link wölbt sich um alle sich darin befindenden Pakete (vgl. <xref linkend="fig_linkpacket" />).</para>
		<figure xml:id="fig_linkpacket">
			<title>Ein Link mit 2 Paketen</title>
			<screenshot>
				<mediaobject>
					<imageobject>
						<imagedata align="center" width="100%" type="PNG" fileref="image/screenshot_link_packets.png" />
					</imageobject>
				</mediaobject>
			</screenshot>
		</figure>
		<para>
			Um dies zu realisieren müssen die Vertexdaten des <link linkend="section_links">gebogenen Links</link> 
			(vgl. <xref linkend="section_links" />) verändert werden. Da der Link durch die <trademark class="registered">OpenGL</trademark>
			Evaluatoren erzeugt wird, sind der Anwendung nur die Kontrollpunkte, aber nicht die kompletten Vertexdaten bekannt.
		</para>
		<para>
			Wie in <xref linkend="fig_renderpipeline" /> zu sehen ist, werden nach den Evaluatoren die Vertexoperationen durchgeführt. 
			Vertexshader<footnote><para>Mehr Information zu Vertexshader sind im Kapitel <xref linkend="section_shader" /> oder 
			in <xref linkend="book_orangebook" /> zu finden.</para></footnote> kommen an dieser Stelle zum Einsatz. 
			Deshalb wurde ein Vertexshader, mit der Aufgabe den Link um die Pakete zu vergrößern, implementiert.
			Der Shader nimmt als Parameter die Position von bis zu 9 Paketen und ist immer nur dann aktiv, wenn gerade ein
			Link gerendert wird. Die Kontrollpunkte werden von den Evaluatoren evaluiert und die berechneten Vertexdaten
			an den Shader übergeben. Dieser berechnet jetzt aus dem aktuellen Vertex, und alle ihm bekannten Paketpositionen,
			ob und wieviel sich der Vertex verschiebt. 
		</para>
		<para>
			Diese Lösung hat den Nachteil dass Systeme, die keinen Shadersupport bieten, auf diese Animation verzichten müssen.
			Siehe Kapitel <xref linkend="section_shader" />.
		</para>
	</section>
	
	<xi:include href="gui.xml" />
</section>
