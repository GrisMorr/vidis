<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Simulator</title>
	<para>
		Im folgenden Abschnitt wird die Implementierung des in
		<xref linkend="design.simulator" /> definierten Simulators
		für VIDIS beschrieben. Dazu werden die im Wesentlichen implementierten
		Aufgaben des Simulators und deren Umsetzung beschrieben und die 
		Funktionsweise der Simulationsschleife mittels Analyse der 
		dazu notwendigen Schritte erörtert.
	</para>
	<section>
		<title>Modul einlesen</title>
		<para>
			In diesem Kapitel wird die Implementierung der
			Funktionalität des Modul laden beschrieben.
		</para>
		<para>
			Der Simulator versucht beim Laden einer MSIM-Datei,
			einen InputStream zu dieser Datei zu öffnen und übergibt
			diesen der Klasse <classname>XMLModuleReader</classname>.
		</para>
		<para>
			Die Klasse <classname>XMLModuleReader</classname> implementiert
			das Interface <interfacename>CommonDomParser</interfacename>.
			Entsprechend kommt in VIDIS ein DOM XML-Parser zum Einsatz.
			Nachdem die Klasse <classname>XMLModuleReader</classname> das 
			XML Dokument analysiert hat, werden die gewonnenen Daten als
			<classname>DocumentData</classname> an den Simulator zurückgegeben.
		</para>
		<para>
			Der Simulator übernimmt anschließend die gewonnenen Daten
			aus der <classname>DocumentData</classname> Klasse in die
			interne Datenstruktur. Dazu werden alle relevanten
			Instanzen der Modul Objekte erzeugt und anschließend
			initialisiert. Folgende Arbeitsschritte werden dafür durchlaufen:
			<variablelist>
				<varlistentry>
					<term>Player stoppen</term>
					<listitem>
						<para>
							Sollte vorher ein anderes Modul geladen worden sein,
							was in der Regel der Fall ist, muss der Player
							gestoppt werden. Dies verhindert unvorhersehbares Verhalten
							beim nächsten Schritt.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Alte Modul Objekt Instanzen löschen</term>
					<listitem>
						<para>
							In diesem Schritt werden nun nicht mehr benötigte
							Objekt Instanzen gelöscht. Dazu wird die Funktion
							<methodsynopsis>
								<modifier>public</modifier>
								<type>void</type>
								<methodname>kill</methodname>
								<void/>
							</methodsynopsis>
							, welche im Interface <interfacename>IComponent</interfacename>
							definiert ist, aufgerufen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Nodes initialisieren</term>
					<listitem>
						<para>
							Alle Node Instanzen werden in diesem Schritt initialisiert,
							Variablen geladen und anschließend als Simulatorkomponente
							beim Simulator registriert.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Links initialisieren</term>
					<listitem>
						<para>
							Alle Link Instanzen werden in diesem Schritt initialisiert,
							Variablen geladen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Nodes über Links verbinden</term>
					<listitem>
						<para>
							Im letzten Schritt werden die Nodes über
							die Links miteinander verbunden. Anschließend
							wird der Link als Simulatorkomponente beim Simulator 
							registriert.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
		<para>
			Der Simulator wurde konzipiert, damit die interne Datenstruktur
			austauschbar und exportierbar ist. Dazu werden alle für die
			Simulation relevanten Informationen in die interne Klasse
			<classname>SimulatorData</classname> gespeichert. Diese implementiert
			das Interface <interfacename>Serializable</interfacename> und
			ist exportierbar. <classname>SimulatorData</classname> implementiert das
			Interface <interfacename>ISimulatorData</interfacename> und bildet
			die Kerndatenstruktur im Simulator. Im folgenden
			Abschnitt wird das Interface <interfacename>ISimulatorData</interfacename> erläutert.
		</para>
		<para>
			<classsynopsis>
				<ooclass>
					<package>vidis.sim.simulatorInternals</package>
					<modifier>public</modifier>
					<classname>SimulatorData</classname>
				</ooclass>
				<oointerface>
					<package>vidis.sim.simulatorInternals</package>
					<modifier>public</modifier>
					<interfacename>ISimulatorData</interfacename>
				</oointerface>
			</classsynopsis>
		</para>
		<para>
			Diese Funktion wird vom Simulator zu jedem Simulationsschritt
			aufgerufen und führt alle Komponenten des Moduls zu einem
			Simulationsschritt aus.
			<methodsynopsis>
				<modifier>public</modifier>
				<type>void</type>
				<methodname>executeComponents</methodname>
				<void/>
			</methodsynopsis>
		</para>
		<para>
			Diese Funktion gibt den aktuellen Zeitpunkt (Simulationsschritt) zurück.
			<methodsynopsis>
				<modifier>public</modifier>
				<type>long</type>
				<methodname>getTime</methodname>
				<void/>
			</methodsynopsis>
			<note>
				<para>
					Jede Simulation startet beim Zeitpunkt <quote>0</quote>
					und mit jedem Simulationsschritt wird dieser Wert um 1
					erhöht.
				</para>
			</note>
		</para>
		<para>
			Diese Funktion setzt die aktuellen Simulationsschritte zurück.
			Unmittelbar nach einem Aufruf dieser Funktion, wird ein Aufruf
			von <methodname>getTime</methodname> das Ergebnis <quote>0</quote>
			liefern.
			<methodsynopsis>
				<modifier>public</modifier>
				<type>void</type>
				<methodname>reset</methodname>
				<void/>
			</methodsynopsis>
		</para>
		<para>
			Diese Funktion ruft auf allen Komponenten die Funktion <methodname>kill</methodname> auf.
			<methodsynopsis>
				<modifier>public</modifier>
				<type>void</type>
				<methodname>killComponents</methodname>
				<void/>
			</methodsynopsis>
		</para>
	</section>
	<section>
		<title>Variablen</title>
		<para>
			Im Simulator ist eine autarke Variablenstruktur
			integriert. Diese übernimmt die Aufgabe den Status
			einer Modulkomponente zu überwachen indem Methoden
			und Felder mittels Java Reflection beobachtet werden.
			Es werden nur Methoden und Variablen überwacht, welche
			mittels Java Annotations (vgl. <xref linkend="implementation.modules.variableannotations" />) gekennzeichnet wurden. Im
			folgenden Kapitel wird die implementierte Funktionalität
			dieser Variablen beschrieben.
		</para>
		<para>
			Eine Variable bildet die Grundlage des automatisierten
			Überwachens eines Moduls. Eine Variable wird durch einen
			Identifier identifiziert. Außerdem können sich bei einer
			Variable Klassen registrieren, welche dann über Änderungen
			am Wert der Variable informiert werden. Eine Variable implementiert
			das Interface <interfacename>IVariable</interfacename> welches
			im Folgenden beschrieben wird.
		</para>
		<itemizedlist>
			<title>Durch das Interface IVariable definierte Methoden</title>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>String</type>
					<methodname>getIdentifier</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode liefert den Identifier der Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>String</type>
					<methodname>getNameSpace</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode liefert den Namespace (Scope oder Gültigkeitsbereich)
					dieser Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Class&lt;?&gt;</type>
					<methodname>getDataType</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode gibt den Datentyp dieser Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Object</type>
					<methodname>getData</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode kann auf die Daten
					dieser Variable zugegriffen werden.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Object</type>
					<methodname>getData</methodname>
					<methodparam><type>Object...</type><parameter>args</parameter></methodparam>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode kann auf die Daten
					dieser Variable zugegriffen werden, falls
					die Variable dazu Parameter benötigt.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>update</methodname>
					<methodparam><type>Object</type><parameter>data</parameter></methodparam>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode können die Daten dieses
					Objekts bearbeitet werden.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Es gibt 3 verschiedene Arten von Variablen basierend
			auf der Zugriffsart. So wird mittels Reflection ein
			Feld auf eine andere Art angesprochen wie eine Methode.
			Die verschiedenen Implementierungen 
			<classname>MethodVariable</classname>, <classname>FieldVariable</classname>
			und <classname>DefaultVariable</classname> werden hinter dem Interface
			<interfacename>IVariable</interfacename> versteckt.
			Im Folgenden werden diese Implementierungen näher beschrieben.
		</para>
		<variablelist>
			<title>Implementierungen des Interface <interfacename>IVariable</interfacename></title>
			<varlistentry>
				<term>DefaultVariable</term>
				<listitem>
					<para>
						Diese Implementierung wird für alle statischen
						Variablen verwendet. Unter statisch versteht
						man hierbei die Zugriffsart auf die Daten.
						Eine statische Datenart ist ein Wert der sich
						nur mittels einem Aufruf von <methodname>update</methodname>
						ändern kann, da keine dynamische Datenquelle
						sich hinter dieser Variablen verbirgt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>FieldVariable</term>
				<listitem>
					<para>
						Eine FieldVariable kommt zum Einsatz wenn ein
						Feld einer Klasse als Datenquelle in Frage kommt.
						Dies wurde folgendermaßen realisiert.
					</para>
					<programlisting>
						<![CDATA[
							private Object invoke() throws IllegalArgumentException, IllegalAccessException {
								Object tmp = field.get(object);
								if (tmp.equals(last_value)) {
								} else {
									changed = true;
									last_value = tmp;
								}
								return tmp;
							}
							public Object getData() {
								try {
									return invoke();
								} catch (IllegalArgumentException e) {
									logger.error(e);
								} catch (IllegalAccessException e) {
									logger.error(e);
								}
								return null;
							}
							public Class<?> getDataType() {
								return field.getType();
							}
						]]>
					</programlisting>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MethodVariable</term>
				<listitem>
					<para>
						Dies ist wohl komplexeste Implementierung,
						da diese den dynamischen Zugriff auf Methoden
						mit oder ohne Parameter realisiert. Die
						eigentliche Komplexität in Verwendung mit
						Parametern liegt im Aufruf von <methodname>getData</methodname>.
						Die Funktionalität wurde folgendermaßen implementiert.
					</para>
					<programlisting>
						<![CDATA[
						public Class<?> getDataType() {
							return method.getReturnType();
						}
						public Object getData() {
					    	try {
								return method.invoke(object);
							} catch (IllegalArgumentException e) {
								logger.error(e);
							} catch (IllegalAccessException e) {
								logger.error(e);
							} catch (InvocationTargetException e) {
								logger.error(e);
							}
							return null;
					    }
					    public Object getData(Object... args) {
					    	try {
								return method.invoke(object, args);
							} catch (IllegalArgumentException e) {
								logger.error(e);
							} catch (IllegalAccessException e) {
								logger.error(e);
							} catch (InvocationTargetException e) {
								logger.error(e);
							}
							return null;
	  					}
						]]>
					</programlisting>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section>
		<title>Arbeitsweise</title>
		<para>
			Der Simulator arbeitet schrittweise. Ein Arbeitsschritt
			stellt einen vollständigen Simulationsschritt dar. In 
			diesem Simulationsschritt werden alle Komponenten einmal
			ausgeführt und bereits vorhandene Aktionen weitergeführt.
		</para>
		<section>
			<title>Grundlegende Arbeitsweise</title>
			<para>
				Zunächst werden falls nötig alle Variablen initialisiert.
			</para>
			<para>
				Anschließend werden simulatorinterne Operationen ausgeführt.
				Im Falle eines Links wäre dies der Transport eines Paketes.
			</para>
			<para>
				Anschließend werden alle Komponenten seriell ausgeführt.
				Dazu wird <methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>execute</methodname>
					<void/>
				</methodsynopsis> aufgerufen.
			</para>
			<para>
				Am Schluss werden nochmals alle Variablen auf Änderungen
				überprüft. Gegebenenfalls wird die Visualisierungskomponente
				über die Änderungen informiert.
			</para>
		</section>
		<section>
			<title>Detaillierte Beschreibung der Ablaufreihenfolge</title>
			<para>
				<variablelist>
					<varlistentry xml:id="implementation.module.node">
						<term>Node</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Sollte dies der erste Simulationsschritt sein,
										so muss die initialisierende Funktion der Modulkomponente
										aufgerufen werden. Folgender Pseudocode veranschaulicht diesen
										Prozess:
									</para>
									<programlisting format="linespecific">
										if simulationStep=1 then
											moduleComponent.init()
										fi
									</programlisting>
								</listitem>
								<listitem>
									<para>
										Es ist möglich Pakete zeitversetzt abzuschicken
										um so eine Bearbeitungszeit zu simulieren. Für
										diese Funktionalität müssen die in Bearbeitung 
										befindliche Pakete vom Simulator in einem Simulator Node 
										verarbeitet werden. Folgender
										Pseudocode veranschaulicht diesen Prozess:
									</para>
									<programlisting format="linespecific">
										<![CDATA[
										packetQueue := { p | p is a queued packet }
										for i in [0 .. #packetQueue] do
										    if packetQueue[i].timeout < 0 then
										    	// send it
										    	doSendOperation packetQueue[i]
												// remove it from the queue
												doRemoveOperation packetQueue[i]
												// decrease running variable
												i -= 1;
										    else
												// decrease queue
												packetQueue[i].timeout -= 1
										    fi
										done
										]]>
									</programlisting>
								</listitem>
								<listitem>
									<para>
										Anschließend wird die vom Benutzer implementierte
										Funktion ausgeführt, falls diese Komponente nicht
										durch einen Aufruf von <methodsynopsis>
											<modifier>public</modifier>
											<type>void</type>
											<methodname>sleep</methodname>
											<methodparam><type>long</type><parameter>steps</parameter></methodparam>
										</methodsynopsis> in den Zustand <varname>schlafend</varname>
										versetzt wurde.
									</para>
									<programlisting format="linespecific">
										<![CDATA[
											if !sleeping then
												moduleComponent.execute()
											fi
										]]>
									</programlisting>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen durch
										Events an die Visualisierung weitergegeben.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
					<varlistentry xml:id="implementation.module.link">
						<term>Link</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Zunächst werden alle Pakete, welche gerade über diesen
										Link transportiert werden, verarbeitet. Folgender
										Pseudocode veranschaulicht diesen Vorgang:
									</para>
									<programlisting format="linespecific">
										<![CDATA[
										queue := { p | p is a packet that is being transported }
										delay := this is the predefined delay of this link
										for i in [0 .. #queue] do
										    if queue[i].timeout > delay then
												// remove it from the queue
												// and let receiver receive it
												doReceiveOperation queue[i]
										    else
												// push this packet further on
												queue[i].timeout += 1
										    fi
										done
										]]>
									</programlisting>
								</listitem>
								<listitem>
									<para>
										Anschließend wird die vom Benutzer implementierte
										Funktion ausgeführt, falls diese Komponente nicht
										durch einen Aufruf von <methodsynopsis>
											<modifier>public</modifier>
											<type>void</type>
											<methodname>sleep</methodname>
											<methodparam><type>long</type><parameter>steps</parameter></methodparam>
										</methodsynopsis> in den Zustand <quote>schlafend</quote>
										versetzt wurde.
									</para>
									<programlisting format="linespecific">
										<![CDATA[
											if !sleeping then
												moduleComponent.execute()
											fi
										]]>
									</programlisting>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen auf der grafischen Benutzeroberfläche
										visualisiert.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
					<varlistentry xml:id="implementation.module.packet">
						<term>Packet</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Da ein Paket keine ausführbare Einheit darstellt
										und nur Daten transportiert, ist es nicht
										sinnvoll auf einem Paket Operationen auszuführen.
										Aus diesem Grund wurde die Methode <methodname>execute</methodname>
										durch einer nicht überschreib- oder überladbaren aber leeren Methode implementiert.
										<programlisting>
											public final void execute() {
												// this component does not execute
											}
										</programlisting>
									</para>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen durch
										Events an die Visualisierung weitergegeben.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
		</section>
	</section>
</section>