<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Simulator</title>
	<para>
		Im folgenden Abschnitt wird die Implementierung des in
		<xref linkend="design.simulator" /> definierten Simulators
		für VIDIS beschrieben. Dazu werden die
		Aufgaben des Simulators und deren Umsetzung beschrieben. Weiters
		wird im Detail die 
		Funktionsweise der Simulationsschleife mittels Analyse der 
		dazu notwendigen Schritte erörtert.
	</para>
	<section>
		<title>Modul einlesen</title>
		<para>
			In diesem Kapitel wird die Implementierung der
			Funktionalität des Modul laden beschrieben.
		</para>
		<para>
			Der Simulator versucht beim Laden einer MSIM-Datei,
			einen InputStream zu dieser Datei zu öffnen und übergibt
			diesen der Klasse <classname>XMLModuleReader</classname>.
		</para>
		<para>
			Die Klasse <classname>XMLModuleReader</classname> implementiert
			das Interface <interfacename>CommonDomParser</interfacename>.
			Entsprechend kommt in VIDIS ein DOM XML-Parser zum Einsatz.
			Nachdem die Klasse <classname>XMLModuleReader</classname> das 
			XML Dokument analysiert hat, werden die gewonnenen Daten als
			<classname>DocumentData</classname> an den Simulator zurückgegeben.
		</para>
		<para>
			Der Simulator übernimmt anschließend die gewonnenen Daten
			aus der <classname>DocumentData</classname> Klasse in die
			interne Datenstruktur. Dazu werden alle relevanten
			Instanzen der Modul Objekte erzeugt und anschließend
			initialisiert. Folgende Arbeitsschritte werden dafür durchlaufen:
			<variablelist>
				<varlistentry>
					<term>Player stoppen</term>
					<listitem>
						<para>
							Sollte vorher ein anderes Modul geladen worden sein,
							was in der Regel der Fall ist, muss der Player
							gestoppt werden. Dies verhindert unvorhersehbares Verhalten
							beim nächsten Schritt.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Alte Modul Objekt Instanzen löschen</term>
					<listitem>
						<para>
							In diesem Schritt werden nun nicht mehr benötigte
							Objekt Instanzen gelöscht. Dazu wird die Funktion
							<methodsynopsis>
								<modifier>public</modifier>
								<type>void</type>
								<methodname>kill</methodname>
								<void/>
							</methodsynopsis>
							welche im Interface <interfacename>IComponent</interfacename>
							definiert ist, aufgerufen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Nodes initialisieren</term>
					<listitem>
						<para>
							Alle Node Instanzen werden in diesem Schritt initialisiert,
							Variablen geladen und anschließend als Simulatorkomponente
							beim Simulator registriert.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Links initialisieren</term>
					<listitem>
						<para>
							Alle Link Instanzen werden in diesem Schritt initialisiert,
							Variablen geladen.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Nodes über Links verbinden</term>
					<listitem>
						<para>
							Im letzten Schritt werden die Nodes über
							die Links miteinander verbunden. Anschließend
							wird der Link als Simulatorkomponente beim Simulator 
							registriert.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
		<para>
			Der Simulator wurde konzipiert, damit die interne Datenstruktur
			austauschbar und exportierbar ist. Dazu werden alle für die
			Simulation relevanten Informationen in die interne Klasse
			<classname>SimulatorData</classname> gespeichert. Diese implementiert
			das Interface <interfacename>Serializable</interfacename> und
			ist exportierbar. <classname>SimulatorData</classname> implementiert das
			Interface <interfacename>ISimulatorData</interfacename> und bildet
			die Kerndatenstruktur im Simulator. Im folgenden
			Abschnitt wird das Interface <interfacename>ISimulatorData</interfacename> erläutert.
		</para>
		<para>
			Die Datenstruktur des Simulators wird durch die Klasse
			<classname>SimulatorData</classname> welche das Interface
			<interfacename>ISimulatorData</interfacename> implementiert.
			Dieses Interface ist folgendermaßen definiert.
			<classsynopsis>
				<ooclass>
					<package>vidis.sim.simulatorInternals</package>
					<modifier>public</modifier>
					<classname>ISimulatorData</classname>
				</ooclass>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>executeComponents</methodname>
					<void/>
				</methodsynopsis>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>long</type>
					<methodname>getTime</methodname>
					<void/>
				</methodsynopsis>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>reset</methodname>
					<void/>
				</methodsynopsis>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>killComponents</methodname>
					<void/>
				</methodsynopsis>
			</classsynopsis>
		</para>
		<itemizedlist>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>executeComponents</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Funktion wird vom Simulator zu jedem Simulationsschritt
					aufgerufen und führt alle Komponenten des Moduls zu einem
					Simulationsschritt aus.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>long</type>
					<methodname>getTime</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Funktion gibt den aktuellen Zeitpunkt (Simulationsschritt) zurück.
					<note>
						<para>
							Jede Simulation startet beim Zeitpunkt <quote>0</quote>
							und mit jedem Simulationsschritt wird dieser Wert um 1
							erhöht.
						</para>
					</note>
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>reset</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Funktion setzt die aktuellen Simulationsschritte zurück.
					Unmittelbar nach einem Aufruf dieser Funktion, wird ein Aufruf
					von <methodname>getTime</methodname> das Ergebnis <quote>0</quote>
					liefern.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>killComponents</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Funktion ruft auf allen Komponenten die Funktion <methodname>kill</methodname> auf.
				</para>
			</listitem>
		</itemizedlist>
	</section>
	<section xml:id="section_variablensystem">
		<title>Variablen</title>
		<para>
			Im Simulator ist eine Variablenstruktur
			integriert. Diese übernimmt die Aufgabe den Status
			einer Modulkomponente zu überwachen, indem Methoden
			und Felder mittels Java Reflection beobachtet werden.
			Es werden nur Methoden und Variablen überwacht, welche
			mittels Java Annotations (vgl. <xref linkend="implementation.modules.variableannotations" />) gekennzeichnet wurden. Im
			folgenden Kapitel wird die implementierte Funktionalität
			dieser Variablen beschrieben.
		</para>
		<para>
			Eine Variable bildet die Grundlage des automatisierten
			Überwachens eines Moduls. Eine Variable wird durch einen
			Bezeichner identifiziert. Außerdem können sich bei einer
			Variable Klassen registrieren, welche dann über Änderungen
			am Wert der Variable informiert werden. Eine Variable implementiert
			das Interface <interfacename>IVariable</interfacename> deren Methoden
			im Folgenden beschrieben wird.
		</para>
		<itemizedlist>
			<title>Durch das Interface IVariable definierte Methoden</title>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>String</type>
					<methodname>getIdentifier</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode liefert den Identifier der Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>String</type>
					<methodname>getNameSpace</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode liefert den Namespace (Scope oder Gültigkeitsbereich)
					dieser Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Class&lt;?&gt;</type>
					<methodname>getDataType</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Diese Methode gibt den Datentyp dieser Variable zurück.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Object</type>
					<methodname>getData</methodname>
					<void/>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode kann auf die Daten
					dieser Variable zugegriffen werden.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>Object</type>
					<methodname>getData</methodname>
					<methodparam><type>Object...</type><parameter>args</parameter></methodparam>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode kann auf die Daten
					dieser Variable zugegriffen werden, falls
					die Variable dazu Parameter benötigt.
				</para>
			</listitem>
			<listitem>
				<methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>update</methodname>
					<methodparam><type>Object</type><parameter>data</parameter></methodparam>
				</methodsynopsis>
				<para>
					Mit Hilfe dieser Methode können die Daten dieses
					Objekts bearbeitet werden.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Es gibt 3 Arten von Variablen die das Interface
			implementieren. Deren Implementierungen realisieren auf
			dem Umstand, dass eine Variable einerseits nur Daten speichern kann,
			aber auch selbst ein Proxy zum Zugriff auf ein Feld oder eine Methode sein kann.
			So wird mittels Reflection ein
			Feld auf eine andere Art angesprochen wie eine Methode.
			Die Klassen 
			<classname>MethodVariable</classname>, <classname>FieldVariable</classname>
			und <classname>DefaultVariable</classname> implementieren das Interface
			<interfacename>IVariable</interfacename>.
			Im Folgenden werden diese Implementierungen näher beschrieben.
		</para>
		<variablelist>
			<title>Implementierungen des Interface <interfacename>IVariable</interfacename></title>
			<varlistentry>
				<term>DefaultVariable</term>
				<listitem>
					<para>
						Diese Implementierung wird für alle 
						Variablen verwendet, welche den Wert beziehungsweise
						das Objekt der Variable selbst speichern.
						Der Inhalt der Variable kann durch den Aufruf von
						<methodname>update</methodname> geändert werden, da
						sich keine dynamische Datenquelle
						hinter dieser Variablen verbirgt.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>FieldVariable</term>
				<listitem>
					<para>
						Eine FieldVariable kommt zum Einsatz wenn ein
						Feld einer Klasse als Datenquelle angesprochen wird.
						Diese Funktionalität wurde mittels Java Reflection
						realisiert. Dabei wird
						das Feld und die Instanz des Objekts abgespeichert.
						Sobald die Daten der Variable durch den Aufruf
						von <methodname>getData</methodname> abgefragt werden,
						greift die Implementierung auf das Feld zu und
						liest die Daten aus der Objektinstanz.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MethodVariable</term>
				<listitem>
					<para>
						Dies ist wohl komplexeste der drei Implementierung,
						da diese den dynamischen Zugriff auf Methoden
						mit oder ohne Parameter realisiert. Realisiert wurde
						diese Funktionalität wiederum mittels Java Reflection.
						Die MethodVariable speichert sich die Objektinstanz zuzsammen
						mit der Methode ab und greift auf dieser beim Aufruf
						von <methodname>getData</methodname> zu. Die
						eigentliche Komplexität liegt im Aufruf von <methodname>getData</methodname>.
						Diese muss alle nötigen Parameter zur Verfügung stellen.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section>
		<title>Arbeitsweise</title>
		<para>
			Der Simulator arbeitet schrittweise. Ein Arbeitsschritt
			stellt einen vollständigen Simulationsschritt dar. In 
			diesem Simulationsschritt werden alle Komponenten genau einmal
			ausgeführt und bereits vorhandene Aktionen weitergeführt.
		</para>
		<section>
			<title>Grundlegende Arbeitsweise</title>
			<para>
				Zunächst werden falls nötig alle Variablen initialisiert.
			</para>
			<para>
				Anschließend werden simulatorinterne Operationen ausgeführt.
				Im Falle eines Links wäre dies zum Beispiel der Transport eines Paketes.
			</para>
			<para>
				Anschließend werden alle Komponenten seriell ausgeführt.
				Dazu wird <methodsynopsis>
					<modifier>public</modifier>
					<type>void</type>
					<methodname>execute</methodname>
					<void/>
				</methodsynopsis> aufgerufen.
			</para>
			<para>
				Am Schluss werden nochmals alle Variablen auf Änderungen
				überprüft. Gegebenenfalls wird die Visualisierungskomponente
				über die Änderungen informiert.
			</para>
		</section>
		<section>
			<title>Detaillierte Beschreibung der Ablaufreihenfolge</title>
			<para>
				Im folgenden wird der Simulationsablauf für jede der Komponenten
				Knoten, Paket und Verbindung im Detail analysiert.
			</para>
			<para>
				<variablelist>
					<varlistentry xml:id="implementation.module.node">
						<term>Knoten</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Sollte dies der erste Simulationsschritt sein,
										so muss die initialisierende Funktion der Modulkomponente
										aufgerufen werden. Folgender Pseudocode veranschaulicht diesen
										Prozess:
									</para>
									<programlisting format="linespecific">if simulationStep=1 then
	moduleComponent.init()
fi</programlisting>
								</listitem>
								<listitem>
									<para>
										Es ist möglich Pakete zeitversetzt abzuschicken
										um so eine Bearbeitungszeit zu simulieren. Für
										diese Funktionalität müssen die in Bearbeitung 
										befindliche Pakete vom Simulator in einem Simulator Node 
										verarbeitet werden. Folgender
										Pseudocode veranschaulicht diesen Prozess:
									</para>
									<programlisting format="linespecific"><![CDATA[packetQueue := { p | p is a queued packet }
for i in [0 .. #packetQueue] do
    if packetQueue[i].timeout < 0 then
    	// send it
    	doSendOperation packetQueue[i]
		// remove it from the queue
		doRemoveOperation packetQueue[i]
		// decrease running variable
		i -= 1;
    else
		// decrease queue
		packetQueue[i].timeout -= 1
    fi
done]]></programlisting>
								</listitem>
								<listitem>
									<para>
										Anschließend wird die vom Benutzer implementierte
										Funktion <methodname>execute</methodname> ausgeführt, falls diese Komponente nicht
										durch einen Aufruf von <methodsynopsis>
											<modifier>public</modifier>
											<type>void</type>
											<methodname>sleep</methodname>
											<methodparam><type>long</type><parameter>steps</parameter></methodparam>
										</methodsynopsis> in den Zustand <varname>schlafend</varname>
										versetzt wurde.
									</para>
									<programlisting format="linespecific"><![CDATA[if !sleeping then
	moduleComponent.execute()
fi]]></programlisting>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen durch
										Events an die Visualisierung weitergegeben.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
					<varlistentry xml:id="implementation.module.link">
						<term>Verbindung</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Zunächst werden alle Pakete, welche gerade über diesen
										Link transportiert werden, verarbeitet. Folgender
										Pseudocode veranschaulicht diesen Vorgang:
									</para>
									<programlisting format="linespecific"><![CDATA[queue := { p | p is a packet that is being transported }
delay := this is the predefined delay of this link
for i in [0 .. #queue] do
    if queue[i].timeout > delay then
		// remove it from the queue
		// and let receiver receive it
		doReceiveOperation queue[i]
    else
		// push this packet further on
		queue[i].timeout += 1
    fi
done]]></programlisting>
								</listitem>
								<listitem>
									<para>
										Anschließend wird die vom Benutzer implementierte
										Funktion <methodname>execute</methodname> ausgeführt, falls diese Komponente sich nicht
										im Zustand "schlafend" befindet. Die Komponente kann durch einen Aufruf <methodsynopsis>
											<modifier>public</modifier>
											<type>void</type>
											<methodname>sleep</methodname>
											<methodparam><type>long</type><parameter>steps</parameter></methodparam>
										</methodsynopsis> in den Zustand <quote>schlafend</quote>
										versetzt werden.
									</para>
									<programlisting format="linespecific"><![CDATA[if !sleeping then
	moduleComponent.execute()
fi
]]></programlisting>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen auf der grafischen Benutzeroberfläche
										visualisiert.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
					<varlistentry xml:id="implementation.module.packet">
						<term>Paket</term>
						<listitem>
							<itemizedlist>
								<listitem>
									<para>
										Da ein Paket keine ausführbare Einheit darstellt
										und nur Daten transportiert, ist es nicht
										sinnvoll auf einem Paket Operationen auszuführen.
										Aus diesem Grund wurde die Methode <methodname>execute</methodname>
										durch einer nicht überschreib- oder überladbaren aber leeren Methode implementiert.
<programlisting><![CDATA[public final void execute() {
	// this component does not execute
}]]></programlisting>
									</para>
								</listitem>
								<listitem>
									<para>
										Schlussendlich werden alle Änderungen an
										den Variablen durch
										Events an die Visualisierung weitergegeben.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
		</section>
	</section>
</section>